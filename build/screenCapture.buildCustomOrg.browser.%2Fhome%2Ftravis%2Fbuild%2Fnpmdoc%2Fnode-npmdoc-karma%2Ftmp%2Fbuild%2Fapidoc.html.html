<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://karma-runner.github.io/">karma (v1.6.0)</a>
</h1>
<h4>Spectacular Test Runner for JavaScript.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma">module karma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server">
            function <span class="apidocSignatureSpan">karma.</span>Server
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_">
            function <span class="apidocSignatureSpan">karma.</span>Server.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.</span>launcher.Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>launcher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>runner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>stopper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">karma.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server">module karma.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.Server">
            function <span class="apidocSignatureSpan">karma.</span>Server
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.start">
            function <span class="apidocSignatureSpan">karma.Server.</span>start
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_">
            function <span class="apidocSignatureSpan">karma.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server.prototype">module karma.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._detach">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_detach
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._setUpLoadErrorListener">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_setUpLoadErrorListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._start">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_start
            <span class="apidocSignatureSpan">(config, launcher, preprocess, fileList, capturedBrowsers, executor, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.get">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>get
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.refreshFiles">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>refreshFiles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.start">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server.super_">module karma.Server.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_.super_">
            function <span class="apidocSignatureSpan">karma.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.config">module karma.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.config.parseConfig">
            function <span class="apidocSignatureSpan">karma.config.</span>parseConfig
            <span class="apidocSignatureSpan">(configFilePath, cliOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.launcher">module karma.launcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.launcher.Launcher">module karma.launcher.Launcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher.generateId">
            function <span class="apidocSignatureSpan">karma.launcher.Launcher.</span>generateId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.runner">module karma.runner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.runner.run">
            function <span class="apidocSignatureSpan">karma.runner.</span>run
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.server">module karma.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.server.start">
            function <span class="apidocSignatureSpan">karma.server.</span>start
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.stopper">module karma.stopper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.stopper.stop">
            function <span class="apidocSignatureSpan">karma.stopper.</span>stop
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma" id="apidoc.module.karma">module karma</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server" id="apidoc.element.karma.Server">
        function <span class="apidocSignatureSpan">karma.</span>Server
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (cliOptions, done) {
  EventEmitter.call(this)

  logger.setupFromConfig(cliOptions)

  this.log = logger.create()

  this.loadErrors = []

  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)

  var modules = [{
    helper: ['value', helper],
    logger: ['value', logger],
    done: ['value', done || process.exit],
    emitter: ['value', this],
    server: ['value', this],
    launcher: ['type', Launcher],
    config: ['value', config],
    preprocess: ['factory', preprocessor.createPreprocessor],
    fileList: ['type', FileList],
    webServer: ['factory', ws.create],
    socketServer: ['factory', createSocketIoServer],
    executor: ['type', Executor],
    // TODO(vojta): remove
    customFileHandlers: ['value', []],
    // TODO(vojta): remove, once karma-dart does not rely on it
    customScriptTypes: ['value', []],
    reporter: ['factory', reporter.createReporters],
    capturedBrowsers: ['type', BrowserCollection],
    args: ['value', {}],
    timer: ['value', {
      setTimeout: function () {
        return setTimeout.apply(root, arguments)
      },
      clearTimeout: function (timeoutId) {
        clearTimeout(timeoutId)
      }
    }]
  }]

  this._setUpLoadErrorListener()
  // Load the plugins
  modules = modules.concat(plugin.resolve(config.plugins, this))

  this._injector = new di.Injector(modules)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.super_" id="apidoc.element.karma.Server.super_">
        function <span class="apidocSignatureSpan">karma.</span>Server.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server.super_ = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
    // TODO(vojta): allow passing args
    // TODO(vojta): ignore/throw if listener call done() multiple times
    var pending = this.listeners(name).length
    var deferred = helper.defer()
    var done = function () {
      if (!--pending) {
        deferred.resolve()
      }
    }

    this.emit(name, done)

    if (!pending) {
      deferred.resolve()
    }

    return deferred.promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher" id="apidoc.element.karma.launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.</span>launcher.Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launcher.Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &lt; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + '//' + hostname + ':' + port + urlRoot

      var locals = {
        id: ['value', Launcher.generateId()],
        name: ['value', name],
        processKillTimeout: ['value', processKillTimeout],
        baseLauncherDecorator: ['factory', baseDecorator],
        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],
        retryLauncherDecorator: ['factory', retryDecorator],
        processLauncherDecorator: ['factory', processDecorator],
        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf('/') !== -1) {
        name = 'Script'
      }

      try {
        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)
      } catch (e) {
        if (e.message.indexOf('No provider for "launcher:' + name + '"') !== -1) {
          log.error('Cannot load browser "%s": it is not registered! ' +
            'Perhaps you are missing some plugin?', name)
        } else {
          log.error('Cannot load browser "%s"!\n  ' + e.stack, name)
        }

        emitter.emit('load_error', 'launcher', name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on('browser_process_failure', function () {
          done(browser.error)
        })

        browser.on('done', function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      'Launching browser%s %s with %s',
      names.length &gt; 1 ? 's' : '',
      names.join(', '),
      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on('end', function (err) {
      log.debug('Finished all browsers')

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    'config.browsers',
    'config.concurrency',
    'config.processKillTimeout'
  ]

  this.launchSingle.$inject = [
    'config.protocol',
    'config.hostname',
    'config.port',
    'config.urlRoot',
    'config.upstreamProxy',
    'config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server" id="apidoc.module.karma.Server">module karma.Server</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.Server" id="apidoc.element.karma.Server.Server">
        function <span class="apidocSignatureSpan">karma.</span>Server
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (cliOptions, done) {
  EventEmitter.call(this)

  logger.setupFromConfig(cliOptions)

  this.log = logger.create()

  this.loadErrors = []

  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)

  var modules = [{
    helper: ['value', helper],
    logger: ['value', logger],
    done: ['value', done || process.exit],
    emitter: ['value', this],
    server: ['value', this],
    launcher: ['type', Launcher],
    config: ['value', config],
    preprocess: ['factory', preprocessor.createPreprocessor],
    fileList: ['type', FileList],
    webServer: ['factory', ws.create],
    socketServer: ['factory', createSocketIoServer],
    executor: ['type', Executor],
    // TODO(vojta): remove
    customFileHandlers: ['value', []],
    // TODO(vojta): remove, once karma-dart does not rely on it
    customScriptTypes: ['value', []],
    reporter: ['factory', reporter.createReporters],
    capturedBrowsers: ['type', BrowserCollection],
    args: ['value', {}],
    timer: ['value', {
      setTimeout: function () {
        return setTimeout.apply(root, arguments)
      },
      clearTimeout: function (timeoutId) {
        clearTimeout(timeoutId)
      }
    }]
  }]

  this._setUpLoadErrorListener()
  // Load the plugins
  modules = modules.concat(plugin.resolve(config.plugins, this))

  this._injector = new di.Injector(modules)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.start" id="apidoc.element.karma.Server.start">
        function <span class="apidocSignatureSpan">karma.Server.</span>start
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cliOptions, done) {
  var server = new Server(cliOptions, done)
  server.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.super_" id="apidoc.element.karma.Server.super_">
        function <span class="apidocSignatureSpan">karma.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
    // TODO(vojta): allow passing args
    // TODO(vojta): ignore/throw if listener call done() multiple times
    var pending = this.listeners(name).length
    var deferred = helper.defer()
    var done = function () {
      if (!--pending) {
        deferred.resolve()
      }
    }

    this.emit(name, done)

    if (!pending) {
      deferred.resolve()
    }

    return deferred.promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server.prototype" id="apidoc.module.karma.Server.prototype">module karma.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.prototype._detach" id="apidoc.element.karma.Server.prototype._detach">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_detach
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_detach = function (config, done) {
  var log = this.log
  var tmpFile = tmp.fileSync({keep: true})
  log.info('Starting karma detached')
  log.info('Run "karma stop" to stop the server.')
  log.debug('Writing config to tmp-file %s', tmpFile.name)
  config.detached = false
  try {
    fs.writeFileSync(tmpFile.name, JSON.stringify(config), 'utf8')
  } catch (e) {
    log.error("Couldn't write temporary configuration file")
    done(1)
    return
  }
  var child = spawn(process.argv[0], [path.resolve(__dirname, '../lib/detached.js'), tmpFile.name], {
    detached: true,
    stdio: 'ignore'
  })
  child.unref()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype._setUpLoadErrorListener" id="apidoc.element.karma.Server.prototype._setUpLoadErrorListener">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_setUpLoadErrorListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setUpLoadErrorListener = function () {
  var self = this
  self.on('load_error', function (type, name) {
    self.log.debug('Registered a load error of type %s with name %s', type, name)
    self.loadErrors.push([type, name])
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype._start" id="apidoc.element.karma.Server.prototype._start">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_start
        <span class="apidocSignatureSpan">(config, launcher, preprocess, fileList, capturedBrowsers, executor, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_start = function (config, launcher, preprocess, fileList, capturedBrowsers, executor, done) {
  var self = this
  if (config.detached) {
    this._detach(config, done)
    return
  }

  self._fileList = fileList

  config.frameworks.forEach(function (framework) {
    self._injector.get('framework:' + framework)
  })

  var webServer = self._injector.get('webServer')
  var socketServer = self._injector.get('socketServer')

  // A map of launched browsers.
  var singleRunDoneBrowsers = Object.create(null)

  // Passing fake event emitter, so that it does not emit on the global,
  // we don't care about these changes.
  var singleRunBrowsers = new BrowserCollection(new EventEmitter())

  // Some browsers did not get captured.
  var singleRunBrowserNotCaptured = false

  webServer.on('error', function (e) {
    if (e.code === 'EADDRINUSE') {
      self.log.warn('Port %d in use', config.port)
      config.port++
      webServer.listen(config.port, config.listenAddress)
    } else {
      throw e
    }
  })

  var afterPreprocess = function () {
    if (config.autoWatch) {
      self._injector.invoke(watcher.watch)
    }

    webServer.listen(config.port, config.listenAddress, function () {
      self.log.info('Karma v%s server started at %s//%s:%s%s', constant.VERSION,
        config.protocol, config.listenAddress, config.port, config.urlRoot)

      self.emit('listening', config.port)
      if (config.browsers &amp;&amp; config.browsers.length) {
        self._injector.invoke(launcher.launch, launcher).forEach(function (browserLauncher) {
          singleRunDoneBrowsers[browserLauncher.id] = false
        })
      }
      var noLoadErrors = self.loadErrors.length
      if (noLoadErrors &gt; 0) {
        self.log.error('Found %d load error%s', noLoadErrors, noLoadErrors === 1 ? '' : 's')
        process.exitCode = 1
        process.kill(process.pid, 'SIGINT')
      }
    })
  }

  fileList.refresh().then(afterPreprocess, afterPreprocess)

  self.on('browsers_change', function () {
    // TODO(vojta): send only to interested browsers
    socketServer.sockets.emit('info', capturedBrowsers.serialize())
  })

  self.on('browser_register', function (browser) {
    launcher.markCaptured(browser.id)

    // TODO(vojta): This is lame, browser can get captured and then
    // crash (before other browsers get captured).
    if (launcher.areAllCaptured()) {
      self.emit('browsers_ready')

      if (config.autoWatch) {
        executor.schedule()
      }
    }
  })

  if (config.browserConsoleLogOptions &amp;&amp; config.browserConsoleLogOptions.path) {
    var configLevel = config.browserConsoleLogOptions.level || 'debug'
    var configFormat = config.browserConsoleLogOptions.format || '%b %T: %m'
    var configPath = config.browserConsoleLogOptions.path
    self.log.info('Writing browser console to file: %s', configPath)
    var browserLogFile = fs.openSync(configPath, 'w+')
    var levels = ['log', 'error', 'warn', 'info', 'debug']
    self.on('browser_log', function (browser, message, level) {
      if (levels.indexOf(level.toLowerCase()) &gt; levels.indexOf(configLevel)) return
      if (!helper.isString(message)) {
        message = util.inspect(message, {showHidden: false, colors: false})
      }
      var logMap = {'%m': message, '%t': level.toLowerCase(), '%T': level.toUpperCase(), '%b': browser}
      var logString = configFormat.replace(/%[mtTb]/g, function (m) {
        return logMap[m]
      })
      self.log.debug('Writing browser console line: %s', logString)
      fs.write(browserLogFile, logString + '\n')
    })
  }

  var EVENTS_TO_REPLY = ['start', 'info', 'karma_error', 'result', 'complete']
  socketServer.sockets.on('connection', function (socket) {
    self.log.debug('A browser has connected on socket ' + socket.id)

    var replySocketEvents = events.bufferEvents(socket, EVENTS_TO_REPLY)

    socket.on('complete', function (data, ack) {
      ack()
    })

    socket.on('register', function (info) {
      var newBrowser
      var isRestart

      if (info.id) {
        newBrowser = capturedBrowsers.getById ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.get" id="apidoc.element.karma.Server.prototype.get">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>get
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (token) {
  return this._injector.get(token)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.refreshFiles" id="apidoc.element.karma.Server.prototype.refreshFiles">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>refreshFiles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshFiles = function () {
  if (!this._fileList) return Promise.resolve()

  return this._fileList.refresh()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.start" id="apidoc.element.karma.Server.prototype.start">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  this._injector.invoke(this._start, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server.super_" id="apidoc.module.karma.Server.super_">module karma.Server.super_</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.super_.super_" id="apidoc.element.karma.Server.super_.super_">
        function <span class="apidocSignatureSpan">karma.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.config" id="apidoc.module.karma.config">module karma.config</a></h1>


    <h2>
        <a href="#apidoc.element.karma.config.parseConfig" id="apidoc.element.karma.config.parseConfig">
        function <span class="apidocSignatureSpan">karma.config.</span>parseConfig
        <span class="apidocSignatureSpan">(configFilePath, cliOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseConfig = function (configFilePath, cliOptions) {
  var configModule
  if (configFilePath) {
    log.debug('Loading config %s', configFilePath)

    try {
      configModule = require(configFilePath)
      if (typeof configModule === 'object' &amp;&amp; typeof configModule.default !== 'undefined') {
        configModule = configModule.default
      }
    } catch (e) {
      if (e.code === 'MODULE_NOT_FOUND' &amp;&amp; e.message.indexOf(configFilePath) !== -1) {
        log.error('File %s does not exist!', configFilePath)
      } else {
        log.error('Invalid config file!\n  ' + e.stack)

        var extension = path.extname(configFilePath)
        if (extension === '.coffee' &amp;&amp; !COFFEE_SCRIPT_AVAILABLE) {
          log.error('You need to install CoffeeScript.\n' +
            '  npm install coffee-script --save-dev')
        } else if (extension === '.ls' &amp;&amp; !LIVE_SCRIPT_AVAILABLE) {
          log.error('You need to install LiveScript.\n' +
            '  npm install LiveScript --save-dev')
        } else if (extension === '.ts' &amp;&amp; !TYPE_SCRIPT_AVAILABLE) {
          log.error('You need to install TypeScript.\n' +
            '  npm install typescript ts-node --save-dev')
        }
      }
      return process.exit(1)
    }
    if (!helper.isFunction(configModule)) {
      log.error('Config file must export a function!\n' + CONFIG_SYNTAX_HELP)
      return process.exit(1)
    }
  } else {
    log.debug('No config file specified.')
    // if no config file path is passed, we define a dummy config module.
    configModule = function () {}
  }

  var config = new Config()

  // save and reset hostname and listenAddress so we can detect if the user
  // changed them
  var defaultHostname = config.hostname
  config.hostname = null
  var defaultListenAddress = config.listenAddress
  config.listenAddress = null

  // add the user's configuration in
  config.set(cliOptions)

  try {
    configModule(config)
  } catch (e) {
    log.error('Error in config file!\n', e)
    return process.exit(1)
  }

  // merge the config from config file and cliOptions (precedence)
  config.set(cliOptions)

  // if the user changed listenAddress, but didn't set a hostname, warn them
  if (config.hostname === null &amp;&amp; config.listenAddress !== null) {
    log.warn('ListenAddress was set to %s but hostname was left as the default: ' +
      '%s. If your browsers fail to connect, consider changing the hostname option.',
      config.listenAddress, defaultHostname)
  }
  // restore values that weren't overwritten by the user
  if (config.hostname === null) {
    config.hostname = defaultHostname
  }
  if (config.listenAddress === null) {
    config.listenAddress = defaultListenAddress
  }

  // configure the logger as soon as we can
  logger.setup(config.logLevel, config.colors, config.loggers)

  return normalizeConfig(config, configFilePath)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.launcher" id="apidoc.module.karma.launcher">module karma.launcher</a></h1>


    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher" id="apidoc.element.karma.launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &lt; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + '//' + hostname + ':' + port + urlRoot

      var locals = {
        id: ['value', Launcher.generateId()],
        name: ['value', name],
        processKillTimeout: ['value', processKillTimeout],
        baseLauncherDecorator: ['factory', baseDecorator],
        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],
        retryLauncherDecorator: ['factory', retryDecorator],
        processLauncherDecorator: ['factory', processDecorator],
        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf('/') !== -1) {
        name = 'Script'
      }

      try {
        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)
      } catch (e) {
        if (e.message.indexOf('No provider for "launcher:' + name + '"') !== -1) {
          log.error('Cannot load browser "%s": it is not registered! ' +
            'Perhaps you are missing some plugin?', name)
        } else {
          log.error('Cannot load browser "%s"!\n  ' + e.stack, name)
        }

        emitter.emit('load_error', 'launcher', name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on('browser_process_failure', function () {
          done(browser.error)
        })

        browser.on('done', function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      'Launching browser%s %s with %s',
      names.length &gt; 1 ? 's' : '',
      names.join(', '),
      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on('end', function (err) {
      log.debug('Finished all browsers')

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    'config.browsers',
    'config.concurrency',
    'config.processKillTimeout'
  ]

  this.launchSingle.$inject = [
    'config.protocol',
    'config.hostname',
    'config.port',
    'config.urlRoot',
    'config.upstreamProxy',
    'config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.launcher.Launcher" id="apidoc.module.karma.launcher.Launcher">module karma.launcher.Launcher</a></h1>


    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher.Launcher" id="apidoc.element.karma.launcher.Launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &lt; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + '//' + hostname + ':' + port + urlRoot

      var locals = {
        id: ['value', Launcher.generateId()],
        name: ['value', name],
        processKillTimeout: ['value', processKillTimeout],
        baseLauncherDecorator: ['factory', baseDecorator],
        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],
        retryLauncherDecorator: ['factory', retryDecorator],
        processLauncherDecorator: ['factory', processDecorator],
        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf('/') !== -1) {
        name = 'Script'
      }

      try {
        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)
      } catch (e) {
        if (e.message.indexOf('No provider for "launcher:' + name + '"') !== -1) {
          log.error('Cannot load browser "%s": it is not registered! ' +
            'Perhaps you are missing some plugin?', name)
        } else {
          log.error('Cannot load browser "%s"!\n  ' + e.stack, name)
        }

        emitter.emit('load_error', 'launcher', name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on('browser_process_failure', function () {
          done(browser.error)
        })

        browser.on('done', function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      'Launching browser%s %s with %s',
      names.length &gt; 1 ? 's' : '',
      names.join(', '),
      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on('end', function (err) {
      log.debug('Finished all browsers')

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    'config.browsers',
    'config.concurrency',
    'config.processKillTimeout'
  ]

  this.launchSingle.$inject = [
    'config.protocol',
    'config.hostname',
    'config.port',
    'config.urlRoot',
    'config.upstreamProxy',
    'config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher.generateId" id="apidoc.element.karma.launcher.Launcher.generateId">
        function <span class="apidocSignatureSpan">karma.launcher.Launcher.</span>generateId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateId = function () {
  return '' + Math.floor(Math.random() * 100000000)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.runner" id="apidoc.module.karma.runner">module karma.runner</a></h1>


    <h2>
        <a href="#apidoc.element.karma.runner.run" id="apidoc.element.karma.runner.run">
        function <span class="apidocSignatureSpan">karma.runner.</span>run
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (config, done) {
  config = config || {}

  logger.setupFromConfig(config)

  done = helper.isFunction(done) ? done : process.exit
  config = cfg.parseConfig(config.configFile, config)

  var exitCode = 1
  var options = {
    hostname: config.hostname,
    path: config.urlRoot + 'run',
    port: config.port,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    }
  }

  var request = http.request(options, function (response) {
    response.on('data', function (buffer) {
      var parsedResult = parseExitCode(buffer, exitCode, config.failOnEmptyTestSuite)
      exitCode = parsedResult.exitCode
      process.stdout.write(parsedResult.buffer)
    })

    response.on('end', function () {
      done(exitCode)
    })
  })

  request.on('error', function (e) {
    if (e.code === 'ECONNREFUSED') {
      log.error('There is no server listening on port %d', options.port)
      done(1, e.code)
    } else {
      throw e
    }
  })

  request.end(JSON.stringify({
    args: config.clientArgs,
    removedFiles: config.removedFiles,
    changedFiles: config.changedFiles,
    addedFiles: config.addedFiles,
    refresh: config.refresh,
    colors: config.colors
  }))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.server" id="apidoc.module.karma.server">module karma.server</a></h1>


    <h2>
        <a href="#apidoc.element.karma.server.start" id="apidoc.element.karma.server.start">
        function <span class="apidocSignatureSpan">karma.server.</span>start
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cliOptions, done) {
  console.error('WARN `start` method is deprecated since 0.13. It will be removed in 0.14. Please use \n' +
    '  server = new Server(config, [done])\n' +
    '  server.start()\n' +
    'instead.')
  var server = new Server(cliOptions, done)
  server.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.stopper" id="apidoc.module.karma.stopper">module karma.stopper</a></h1>


    <h2>
        <a href="#apidoc.element.karma.stopper.stop" id="apidoc.element.karma.stopper.stop">
        function <span class="apidocSignatureSpan">karma.stopper.</span>stop
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (config, done) {
  config = config || {}
  logger.setupFromConfig(config)
  done = helper.isFunction(done) ? done : process.exit
  var log = logger.create('stopper')
  config = cfg.parseConfig(config.configFile, config)

  var options = {
    hostname: config.hostname,
    path: config.urlRoot + 'stop',
    port: config.port,
    method: 'GET'
  }

  var request = http.request(options)

  request.on('response', function (response) {
    if (response.statusCode !== 200) {
      log.error('Server returned status code: ' + response.statusCode)
      done(1)
      return
    }

    log.info('Server stopped.')
    done(0)
  })

  request.on('error', function (e) {
    if (e.code === 'ECONNREFUSED') {
      log.error('There is no server listening on port %d', options.port)
      done(1, e.code)
    } else {
      throw e
    }
  })
  request.end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>