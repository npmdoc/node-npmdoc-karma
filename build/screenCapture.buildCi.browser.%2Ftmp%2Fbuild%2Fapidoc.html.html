<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://karma-runner.github.io/">karma (v1.6.0)</a>
</h1>
<h4>Spectacular Test Runner for JavaScript.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma">module karma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.karma">
            function <span class="apidocSignatureSpan"></span>karma
            <span class="apidocSignatureSpan">(callParentKarmaMethod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server">
            function <span class="apidocSignatureSpan">karma.</span>Server
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_">
            function <span class="apidocSignatureSpan">karma.</span>Server.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.base">
            function <span class="apidocSignatureSpan">karma.</span>base
            <span class="apidocSignatureSpan">(id, emitter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.capture_timeout">
            function <span class="apidocSignatureSpan">karma.</span>capture_timeout
            <span class="apidocSignatureSpan">(timer, captureTimeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.emitter_wrapper">
            function <span class="apidocSignatureSpan">karma.</span>emitter_wrapper
            <span class="apidocSignatureSpan">(emitter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file">
            function <span class="apidocSignatureSpan">karma.</span>file
            <span class="apidocSignatureSpan">(path, mtime, doNotCache)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list">
            function <span class="apidocSignatureSpan">karma.</span>file_list
            <span class="apidocSignatureSpan">(patterns, excludes, emitter, preprocess, batchInterval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.</span>launcher.Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.process">
            function <span class="apidocSignatureSpan">karma.</span>process
            <span class="apidocSignatureSpan">(spawn, tempDir, timer, processKillTimeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.retry">
            function <span class="apidocSignatureSpan">karma.</span>retry
            <span class="apidocSignatureSpan">(retryLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.state_machine">
            function <span class="apidocSignatureSpan">karma.</span>state_machine
            <span class="apidocSignatureSpan">(rli, colors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.url">
            function <span class="apidocSignatureSpan">karma.</span>url
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>cli</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>completion</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>emitter_wrapper.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>file.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>file_list.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>formatters</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>helper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>init</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>launcher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>logger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>plugin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>preprocessor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>proxy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>reporter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>runner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>source_files</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>stopper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>strip_host</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>temp_dir</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>url.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>watcher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>web_server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">karma.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server">module karma.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.Server">
            function <span class="apidocSignatureSpan">karma.</span>Server
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.start">
            function <span class="apidocSignatureSpan">karma.Server.</span>start
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_">
            function <span class="apidocSignatureSpan">karma.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server.prototype">module karma.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._detach">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_detach
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._setUpLoadErrorListener">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_setUpLoadErrorListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._start">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_start
            <span class="apidocSignatureSpan">(config, launcher, preprocess, fileList, capturedBrowsers, executor, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.get">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>get
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.refreshFiles">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>refreshFiles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.start">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server.super_">module karma.Server.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_.super_">
            function <span class="apidocSignatureSpan">karma.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.base">module karma.base</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.base.base">
            function <span class="apidocSignatureSpan">karma.</span>base
            <span class="apidocSignatureSpan">(id, emitter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.base.decoratorFactory">
            function <span class="apidocSignatureSpan">karma.base.</span>decoratorFactory
            <span class="apidocSignatureSpan">(id, emitter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.capture_timeout">module karma.capture_timeout</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.capture_timeout.capture_timeout">
            function <span class="apidocSignatureSpan">karma.</span>capture_timeout
            <span class="apidocSignatureSpan">(timer, captureTimeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.capture_timeout.decoratorFactory">
            function <span class="apidocSignatureSpan">karma.capture_timeout.</span>decoratorFactory
            <span class="apidocSignatureSpan">(timer, captureTimeout)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.cli">module karma.cli</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.cli.argsBeforeDoubleDash">
            function <span class="apidocSignatureSpan">karma.cli.</span>argsBeforeDoubleDash
            <span class="apidocSignatureSpan">(argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.cli.parseClientArgs">
            function <span class="apidocSignatureSpan">karma.cli.</span>parseClientArgs
            <span class="apidocSignatureSpan">(argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.cli.process">
            function <span class="apidocSignatureSpan">karma.cli.</span>process
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.cli.processArgs">
            function <span class="apidocSignatureSpan">karma.cli.</span>processArgs
            <span class="apidocSignatureSpan">(argv, options, fs, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.cli.run">
            function <span class="apidocSignatureSpan">karma.cli.</span>run
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.common">module karma.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.common.PromiseContainer">
            function <span class="apidocSignatureSpan">karma.common.</span>PromiseContainer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.common.createServeFile">
            function <span class="apidocSignatureSpan">karma.common.</span>createServeFile
            <span class="apidocSignatureSpan">(fs, directory, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.common.initializeMimeTypes">
            function <span class="apidocSignatureSpan">karma.common.</span>initializeMimeTypes
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.common.serve404">
            function <span class="apidocSignatureSpan">karma.common.</span>serve404
            <span class="apidocSignatureSpan">(response, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.common.setHeavyCacheHeaders">
            function <span class="apidocSignatureSpan">karma.common.</span>setHeavyCacheHeaders
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.common.setNoCacheHeaders">
            function <span class="apidocSignatureSpan">karma.common.</span>setNoCacheHeaders
            <span class="apidocSignatureSpan">(response)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.completion">module karma.completion</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.completion.completion">
            function <span class="apidocSignatureSpan">karma.</span>completion
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.completion.complete">
            function <span class="apidocSignatureSpan">karma.completion.</span>complete
            <span class="apidocSignatureSpan">(env)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.completion.opositeWord">
            function <span class="apidocSignatureSpan">karma.completion.</span>opositeWord
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.completion.sendCompletion">
            function <span class="apidocSignatureSpan">karma.completion.</span>sendCompletion
            <span class="apidocSignatureSpan">(possibleWords, env)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.config">module karma.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.config.parseConfig">
            function <span class="apidocSignatureSpan">karma.config.</span>parseConfig
            <span class="apidocSignatureSpan">(configFilePath, cliOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.emitter_wrapper">module karma.emitter_wrapper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.emitter_wrapper.emitter_wrapper">
            function <span class="apidocSignatureSpan">karma.</span>emitter_wrapper
            <span class="apidocSignatureSpan">(emitter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.emitter_wrapper.prototype">module karma.emitter_wrapper.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.emitter_wrapper.prototype.addListener">
            function <span class="apidocSignatureSpan">karma.emitter_wrapper.prototype.</span>addListener
            <span class="apidocSignatureSpan">(event, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.emitter_wrapper.prototype.on">
            function <span class="apidocSignatureSpan">karma.emitter_wrapper.prototype.</span>on
            <span class="apidocSignatureSpan">(event, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.emitter_wrapper.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">karma.emitter_wrapper.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.events">module karma.events</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.events.EventEmitter">
            function <span class="apidocSignatureSpan">karma.events.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.events.bindAll">
            function <span class="apidocSignatureSpan">karma.events.</span>bindAll
            <span class="apidocSignatureSpan">(object, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.events.bufferEvents">
            function <span class="apidocSignatureSpan">karma.events.</span>bufferEvents
            <span class="apidocSignatureSpan">(emitter, eventsToBuffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.file">module karma.file</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file.file">
            function <span class="apidocSignatureSpan">karma.</span>file
            <span class="apidocSignatureSpan">(path, mtime, doNotCache)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.file.prototype">module karma.file.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file.prototype.toString">
            function <span class="apidocSignatureSpan">karma.file.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.file_list">module karma.file_list</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.file_list">
            function <span class="apidocSignatureSpan">karma.</span>file_list
            <span class="apidocSignatureSpan">(patterns, excludes, emitter, preprocess, batchInterval)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.file_list.prototype">module karma.file_list.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype._exists">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_exists
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype._findFile">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_findFile
            <span class="apidocSignatureSpan">(path, pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype._isExcluded">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_isExcluded
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype._isIncluded">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_isIncluded
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype._isRefreshing">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_isRefreshing
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype._refresh">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_refresh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype.addFile">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>addFile
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype.changeFile">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>changeFile
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype.refresh">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>refresh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype.reload">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>reload
            <span class="apidocSignatureSpan">(patterns, excludes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.file_list.prototype.removeFile">
            function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>removeFile
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.formatters">module karma.formatters</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.formatters.Coffee">
            function <span class="apidocSignatureSpan">karma.formatters.</span>Coffee
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.formatters.JavaScript">
            function <span class="apidocSignatureSpan">karma.formatters.</span>JavaScript
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.formatters.Live">
            function <span class="apidocSignatureSpan">karma.formatters.</span>Live
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.formatters.Type">
            function <span class="apidocSignatureSpan">karma.formatters.</span>Type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.formatters.createForPath">
            function <span class="apidocSignatureSpan">karma.formatters.</span>createForPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.helper">module karma.helper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.arrayRemove">
            function <span class="apidocSignatureSpan">karma.helper.</span>arrayRemove
            <span class="apidocSignatureSpan">(collection, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.browserFullNameToShort">
            function <span class="apidocSignatureSpan">karma.helper.</span>browserFullNameToShort
            <span class="apidocSignatureSpan">(fullName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.camelToSnake">
            function <span class="apidocSignatureSpan">karma.helper.</span>camelToSnake
            <span class="apidocSignatureSpan">(camelCase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.dashToCamel">
            function <span class="apidocSignatureSpan">karma.helper.</span>dashToCamel
            <span class="apidocSignatureSpan">(dash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.defer">
            function <span class="apidocSignatureSpan">karma.helper.</span>defer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.formatTimeInterval">
            function <span class="apidocSignatureSpan">karma.helper.</span>formatTimeInterval
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.isArray">
            function <span class="apidocSignatureSpan">karma.helper.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.isDefined">
            function <span class="apidocSignatureSpan">karma.helper.</span>isDefined
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.isFunction">
            function <span class="apidocSignatureSpan">karma.helper.</span>isFunction
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.isNumber">
            function <span class="apidocSignatureSpan">karma.helper.</span>isNumber
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.isObject">
            function <span class="apidocSignatureSpan">karma.helper.</span>isObject
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.isString">
            function <span class="apidocSignatureSpan">karma.helper.</span>isString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.isUrlAbsolute">
            function <span class="apidocSignatureSpan">karma.helper.</span>isUrlAbsolute
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.merge">
            function <span class="apidocSignatureSpan">karma.helper.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.mkdirIfNotExists">
            function <span class="apidocSignatureSpan">karma.helper.</span>mkdirIfNotExists
            <span class="apidocSignatureSpan">(directory, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.mmComparePatternWeights">
            function <span class="apidocSignatureSpan">karma.helper.</span>mmComparePatternWeights
            <span class="apidocSignatureSpan">(weight1, weight2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.mmPatternWeight">
            function <span class="apidocSignatureSpan">karma.helper.</span>mmPatternWeight
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.normalizeWinPath">
            function <span class="apidocSignatureSpan">karma.helper.</span>normalizeWinPath
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.helper.ucFirst">
            function <span class="apidocSignatureSpan">karma.helper.</span>ucFirst
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.init">module karma.init</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.init.init">
            function <span class="apidocSignatureSpan">karma.</span>init
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.karma">module karma.karma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.karma.karma">
            function <span class="apidocSignatureSpan">karma.</span>karma
            <span class="apidocSignatureSpan">(callParentKarmaMethod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.karma.getDirectCallParentKarmaMethod">
            function <span class="apidocSignatureSpan">karma.karma.</span>getDirectCallParentKarmaMethod
            <span class="apidocSignatureSpan">(parentWindow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.karma.getPostMessageCallParentKarmaMethod">
            function <span class="apidocSignatureSpan">karma.karma.</span>getPostMessageCallParentKarmaMethod
            <span class="apidocSignatureSpan">(parentWindow)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.launcher">module karma.launcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.launcher.Launcher">module karma.launcher.Launcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher.generateId">
            function <span class="apidocSignatureSpan">karma.launcher.Launcher.</span>generateId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.logger">module karma.logger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.logger.create">
            function <span class="apidocSignatureSpan">karma.logger.</span>create
            <span class="apidocSignatureSpan">(name, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.logger.setup">
            function <span class="apidocSignatureSpan">karma.logger.</span>setup
            <span class="apidocSignatureSpan">(level, colors, appenders)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.logger.setupFromConfig">
            function <span class="apidocSignatureSpan">karma.logger.</span>setupFromConfig
            <span class="apidocSignatureSpan">(config, appenders)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.plugin">module karma.plugin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.plugin.resolve">
            function <span class="apidocSignatureSpan">karma.plugin.</span>resolve
            <span class="apidocSignatureSpan">(plugins, emitter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.preprocessor">module karma.preprocessor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.preprocessor.createPreprocessor">
            function <span class="apidocSignatureSpan">karma.preprocessor.</span>createPreprocessor
            <span class="apidocSignatureSpan">(config, basePath, injector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.process">module karma.process</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.process.process">
            function <span class="apidocSignatureSpan">karma.</span>process
            <span class="apidocSignatureSpan">(spawn, tempDir, timer, processKillTimeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.process.decoratorFactory">
            function <span class="apidocSignatureSpan">karma.process.</span>decoratorFactory
            <span class="apidocSignatureSpan">(timer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.proxy">module karma.proxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.proxy.create">
            function <span class="apidocSignatureSpan">karma.proxy.</span>create
            <span class="apidocSignatureSpan">(config, proxies)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.reporter">module karma.reporter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.reporter.createReporters">
            function <span class="apidocSignatureSpan">karma.reporter.</span>createReporters
            <span class="apidocSignatureSpan">(names, config, emitter, injector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.retry">module karma.retry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.retry.retry">
            function <span class="apidocSignatureSpan">karma.</span>retry
            <span class="apidocSignatureSpan">(retryLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.retry.decoratorFactory">
            function <span class="apidocSignatureSpan">karma.retry.</span>decoratorFactory
            <span class="apidocSignatureSpan">(retryLimit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.runner">module karma.runner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.runner.run">
            function <span class="apidocSignatureSpan">karma.runner.</span>run
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.server">module karma.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.server.start">
            function <span class="apidocSignatureSpan">karma.server.</span>start
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.source_files">module karma.source_files</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.source_files.create">
            function <span class="apidocSignatureSpan">karma.source_files.</span>create
            <span class="apidocSignatureSpan">(filesPromise, serveFile, basePath, urlRoot)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.state_machine">module karma.state_machine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.state_machine.state_machine">
            function <span class="apidocSignatureSpan">karma.</span>state_machine
            <span class="apidocSignatureSpan">(rli, colors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.state_machine.super_">
            function <span class="apidocSignatureSpan">karma.state_machine.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.stopper">module karma.stopper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.stopper.stop">
            function <span class="apidocSignatureSpan">karma.stopper.</span>stop
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.strip_host">module karma.strip_host</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.strip_host.create">
            function <span class="apidocSignatureSpan">karma.strip_host.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.temp_dir">module karma.temp_dir</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.temp_dir.create">
            function <span class="apidocSignatureSpan">karma.temp_dir.</span>create
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.temp_dir.getPath">
            function <span class="apidocSignatureSpan">karma.temp_dir.</span>getPath
            <span class="apidocSignatureSpan">(suffix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.temp_dir.remove">
            function <span class="apidocSignatureSpan">karma.temp_dir.</span>remove
            <span class="apidocSignatureSpan">(path, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.url">module karma.url</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.url.url">
            function <span class="apidocSignatureSpan">karma.</span>url
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.url.prototype">module karma.url.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.url.prototype.toString">
            function <span class="apidocSignatureSpan">karma.url.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.util">module karma.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.util.elm">
            function <span class="apidocSignatureSpan">karma.util.</span>elm
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.util.generateId">
            function <span class="apidocSignatureSpan">karma.util.</span>generateId
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.util.instanceOf">
            function <span class="apidocSignatureSpan">karma.util.</span>instanceOf
            <span class="apidocSignatureSpan">(value, constructorName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.util.isDefined">
            function <span class="apidocSignatureSpan">karma.util.</span>isDefined
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.util.isUndefined">
            function <span class="apidocSignatureSpan">karma.util.</span>isUndefined
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.util.parseQueryParams">
            function <span class="apidocSignatureSpan">karma.util.</span>parseQueryParams
            <span class="apidocSignatureSpan">(locationSearch)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.watcher">module karma.watcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.watcher.watch">
            function <span class="apidocSignatureSpan">karma.watcher.</span>watch
            <span class="apidocSignatureSpan">(patterns, excludes, fileList, usePolling, emitter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.web_server">module karma.web_server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.web_server.create">
            function <span class="apidocSignatureSpan">karma.web_server.</span>create
            <span class="apidocSignatureSpan">(injector, emitter, fileList)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma" id="apidoc.module.karma">module karma</a></h1>


    <h2>
        <a href="#apidoc.element.karma.karma" id="apidoc.element.karma.karma">
        function <span class="apidocSignatureSpan"></span>karma
        <span class="apidocSignatureSpan">(callParentKarmaMethod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">karma = function (callParentKarmaMethod) {
  // Define local variables
  var hasError = false
  var self = this

  // Define our loggers
  // DEV: These are intentionally repeated in client and context
  this.log = function (type, args) {
    var values = []

    for (var i = 0; i &lt; args.length; i++) {
      values.push(this.stringify(args[i], 3))
    }

    this.info({log: values.join(', '), type: type})
  }

  this.stringify = stringify

  // Define our proxy error handler
  // DEV: We require one in our context to track `hasError`
  this.error = function () {
    hasError = true
    callParentKarmaMethod('error', [].slice.call(arguments))
    return false
  }

  // Define our start handler
  var UNIMPLEMENTED_START = function () {
    this.error('You need to include some adapter that implements __karma__.start method!')
  }
  // all files loaded, let's start the execution
  this.loaded = function () {
    // has error -&gt; cancel
    if (!hasError) {
      this.start(this.config)
    }

    // remove reference to child iframe
    this.start = UNIMPLEMENTED_START
  }
  // supposed to be overriden by the context
  // TODO(vojta): support multiple callbacks (queue)
  this.start = UNIMPLEMENTED_START

  // Define proxy methods
  // DEV: This is a closured `for` loop (same as a `forEach`) for IE support
  var proxyMethods = ['complete', 'info', 'result']
  for (var i = 0; i &lt; proxyMethods.length; i++) {
    (function bindProxyMethod (methodName) {
      self[methodName] = function boundProxyMethod () {
        callParentKarmaMethod(methodName, [].slice.call(arguments))
      }
    }(proxyMethods[i]))
  }

  // Define bindings for context window
  this.setupContext = function (contextWindow) {
    // If we clear the context after every run and we already had an error
    //   then stop now. Otherwise, carry on.
    if (self.config.clearContext &amp;&amp; hasError) {
      return
    }

    // Perform window level bindings
    // DEV: We return `self.error` since we want to `return false` to ignore errors
    contextWindow.onerror = function () {
      return self.error.apply(self, arguments)
    }
    // DEV: We must defined a function since we don't want to pass the event object
    contextWindow.onbeforeunload = function (e, b) {
      callParentKarmaMethod('onbeforeunload', [])
    }

    contextWindow.dump = function () {
      self.log('dump', arguments)
    }

    var _confirm = contextWindow.confirm
    var _prompt = contextWindow.prompt

    contextWindow.alert = function (msg) {
      self.log('alert', [msg])
    }

    contextWindow.confirm = function (msg) {
      self.log('confirm', [msg])
      return _confirm(msg)
    }

    contextWindow.prompt = function (msg, defaultVal) {
      self.log('prompt', [msg, defaultVal])
      return _prompt(msg, defaultVal)
    }

    // If we want to overload our console, then do it
    var getConsole = function (currentWindow) {
      return currentWindow.console || {
        log: function () {},
        info: function () {},
        warn: function () {},
        error: function () {},
        debug: function () {}
      }
    }
    if (self.config.captureConsole) {
      // patch the console
      var localConsole = contextWindow.console = getConsole(contextWindow)
      var logMethods = ['log', 'info', 'warn', 'error', 'debug']
      var patchConsoleMethod = function (method) {
        var orig = localConsole[method]
        if (!orig) {
          return
        }
        localConsole[method] = function () {
          self.log(method, arguments)
          return Function.prototype.apply.call(orig, localConsole, arguments)
        }
      }
      for (var i = 0; i &lt; logMethods.length; i++) {
        patchConsoleMethod(logMethods[i])
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server" id="apidoc.element.karma.Server">
        function <span class="apidocSignatureSpan">karma.</span>Server
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (cliOptions, done) {
  EventEmitter.call(this)

  logger.setupFromConfig(cliOptions)

  this.log = logger.create()

  this.loadErrors = []

  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)

  var modules = [{
    helper: ['value', helper],
    logger: ['value', logger],
    done: ['value', done || process.exit],
    emitter: ['value', this],
    server: ['value', this],
    launcher: ['type', Launcher],
    config: ['value', config],
    preprocess: ['factory', preprocessor.createPreprocessor],
    fileList: ['type', FileList],
    webServer: ['factory', ws.create],
    socketServer: ['factory', createSocketIoServer],
    executor: ['type', Executor],
    // TODO(vojta): remove
    customFileHandlers: ['value', []],
    // TODO(vojta): remove, once karma-dart does not rely on it
    customScriptTypes: ['value', []],
    reporter: ['factory', reporter.createReporters],
    capturedBrowsers: ['type', BrowserCollection],
    args: ['value', {}],
    timer: ['value', {
      setTimeout: function () {
        return setTimeout.apply(root, arguments)
      },
      clearTimeout: function (timeoutId) {
        clearTimeout(timeoutId)
      }
    }]
  }]

  this._setUpLoadErrorListener()
  // Load the plugins
  modules = modules.concat(plugin.resolve(config.plugins, this))

  this._injector = new di.Injector(modules)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.super_" id="apidoc.element.karma.Server.super_">
        function <span class="apidocSignatureSpan">karma.</span>Server.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server.super_ = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
    // TODO(vojta): allow passing args
    // TODO(vojta): ignore/throw if listener call done() multiple times
    var pending = this.listeners(name).length
    var deferred = helper.defer()
    var done = function () {
      if (!--pending) {
        deferred.resolve()
      }
    }

    this.emit(name, done)

    if (!pending) {
      deferred.resolve()
    }

    return deferred.promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.base" id="apidoc.element.karma.base">
        function <span class="apidocSignatureSpan">karma.</span>base
        <span class="apidocSignatureSpan">(id, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (id, emitter) {
  if (this.start) {
    return
  }

  // TODO(vojta): figure out how to do inheritance with DI
  Object.keys(EventEmitter.prototype).forEach(function (method) {
    this[method] = EventEmitter.prototype[method]
  }, this)
  KarmaEventEmitter.call(this)

  this.id = id
  this.state = null
  this.error = null

  var self = this
  var killingPromise
  var previousUrl

  this.start = function (url) {
    previousUrl = url

    this.error = null
    this.state = BEING_CAPTURED
    this.emit('start', url + '?id=' + this.id + (helper.isDefined(self.displayName) ? '&amp;displayName=' + encodeURIComponent(self.
displayName) : ''))
  }

  this.kill = function () {
    // Already killed, or being killed.
    if (killingPromise) {
      return killingPromise
    }

    killingPromise = this.emitAsync('kill').then(function () {
      self.state = FINISHED
    })

    this.state = BEING_KILLED

    return killingPromise
  }

  this.forceKill = function () {
    this.kill()
    this.state = BEING_FORCE_KILLED

    return killingPromise
  }

  this.restart = function () {
    if (this.state === BEING_FORCE_KILLED) {
      return
    }

    if (!killingPromise) {
      killingPromise = this.emitAsync('kill')
    }

    killingPromise.then(function () {
      if (self.state === BEING_FORCE_KILLED) {
        self.state = FINISHED
      } else {
        killingPromise = null
        log.debug('Restarting %s', self.name)
        self.start(previousUrl)
      }
    })

    self.state = RESTARTING
  }

  this.markCaptured = function () {
    if (this.state === BEING_CAPTURED) {
      this.state = CAPTURED
    }
  }

  this.isCaptured = function () {
    return this.state === CAPTURED
  }

  this.toString = function () {
    return this.name
  }

  this._done = function (error) {
    killingPromise = killingPromise || Promise.resolve()

    this.error = this.error || error
    this.emit('done')

    if (this.error &amp;&amp; this.state !== BEING_FORCE_KILLED &amp;&amp; this.state !== RESTARTING) {
      emitter.emit('browser_process_failure', this)
    }

    this.state = FINISHED
  }

  this.STATE_BEING_CAPTURED = BEING_CAPTURED
  this.STATE_CAPTURED = CAPTURED
  this.STATE_BEING_KILLED = BEING_KILLED
  this.STATE_FINISHED = FINISHED
  this.STATE_RESTARTING = RESTARTING
  this.STATE_BEING_FORCE_KILLED = BEING_FORCE_KILLED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.capture_timeout" id="apidoc.element.karma.capture_timeout">
        function <span class="apidocSignatureSpan">karma.</span>capture_timeout
        <span class="apidocSignatureSpan">(timer, captureTimeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">capture_timeout = function (timer, captureTimeout) {
  if (!captureTimeout) {
    return
  }

  var self = this
  var pendingTimeoutId = null

  this.on('start', function () {
    pendingTimeoutId = timer.setTimeout(function () {
      pendingTimeoutId = null
      if (self.state !== self.STATE_BEING_CAPTURED) {
        return
      }

      log.warn('%s have not captured in %d ms, killing.', self.name, captureTimeout)
      self.error = 'timeout'
      self.kill()
    }, captureTimeout)
  })

  this.on('done', function () {
    if (pendingTimeoutId) {
      timer.clearTimeout(pendingTimeoutId)
      pendingTimeoutId = null
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.emitter_wrapper" id="apidoc.element.karma.emitter_wrapper">
        function <span class="apidocSignatureSpan">karma.</span>emitter_wrapper
        <span class="apidocSignatureSpan">(emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EmitterWrapper(emitter) {
  this.listeners = {}
  this.emitter = emitter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file" id="apidoc.element.karma.file">
        function <span class="apidocSignatureSpan">karma.</span>file
        <span class="apidocSignatureSpan">(path, mtime, doNotCache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function (path, mtime, doNotCache) {
  // used for serving (processed path, eg some/file.coffee -&gt; some/file.coffee.js)
  this.path = path

  // original absolute path, id of the file
  this.originalPath = path

  // where the content is stored (processed)
  this.contentPath = path

  this.mtime = mtime
  this.isUrl = false

  this.doNotCache = _.isUndefined(doNotCache) ? false : doNotCache
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list" id="apidoc.element.karma.file_list">
        function <span class="apidocSignatureSpan">karma.</span>file_list
        <span class="apidocSignatureSpan">(patterns, excludes, emitter, preprocess, batchInterval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_list = function (patterns, excludes, emitter, preprocess, batchInterval) {
  // Store options
  this._patterns = patterns
  this._excludes = excludes
  this._emitter = emitter
  this._preprocess = Promise.promisify(preprocess)
  this._batchInterval = batchInterval

  // The actual list of files
  this.buckets = new Map()

  // Internal tracker if we are refreshing.
  // When a refresh is triggered this gets set
  // to the promise that `this._refresh` returns.
  // So we know we are refreshing when this promise
  // is still pending, and we are done when it's either
  // resolved or rejected.
  this._refreshing = Promise.resolve()

  var self = this

  // Emit the `file_list_modified` event.
  // This function is throttled to the value of `batchInterval`
  // to avoid spamming the listener.
  function emit () {
    self._emitter.emit('file_list_modified', self.files)
  }
  var throttledEmit = _.throttle(emit, self._batchInterval, {leading: false})
  self._emitModified = function (immediate) {
    immediate ? emit() : throttledEmit()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher" id="apidoc.element.karma.launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.</span>launcher.Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launcher.Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &lt; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + '//' + hostname + ':' + port + urlRoot

      var locals = {
        id: ['value', Launcher.generateId()],
        name: ['value', name],
        processKillTimeout: ['value', processKillTimeout],
        baseLauncherDecorator: ['factory', baseDecorator],
        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],
        retryLauncherDecorator: ['factory', retryDecorator],
        processLauncherDecorator: ['factory', processDecorator],
        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf('/') !== -1) {
        name = 'Script'
      }

      try {
        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)
      } catch (e) {
        if (e.message.indexOf('No provider for "launcher:' + name + '"') !== -1) {
          log.error('Cannot load browser "%s": it is not registered! ' +
            'Perhaps you are missing some plugin?', name)
        } else {
          log.error('Cannot load browser "%s"!\n  ' + e.stack, name)
        }

        emitter.emit('load_error', 'launcher', name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on('browser_process_failure', function () {
          done(browser.error)
        })

        browser.on('done', function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      'Launching browser%s %s with %s',
      names.length &gt; 1 ? 's' : '',
      names.join(', '),
      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on('end', function (err) {
      log.debug('Finished all browsers')

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    'config.browsers',
    'config.concurrency',
    'config.processKillTimeout'
  ]

  this.launchSingle.$inject = [
    'config.protocol',
    'config.hostname',
    'config.port',
    'config.urlRoot',
    'config.upstreamProxy',
    'config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.process" id="apidoc.element.karma.process">
        function <span class="apidocSignatureSpan">karma.</span>process
        <span class="apidocSignatureSpan">(spawn, tempDir, timer, processKillTimeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (spawn, tempDir, timer, processKillTimeout) {
  var self = this
  var onExitCallback
  var killTimeout = processKillTimeout || 2000

  this._tempDir = tempDir.getPath('/karma-' + this.id.toString())

  this.on('start', function (url) {
    tempDir.create(self._tempDir)
    self._start(url)
  })

  this.on('kill', function (done) {
    if (!self._process) {
      return process.nextTick(done)
    }

    onExitCallback = done
    self._process.kill()
    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout)
  })

  this._start = function (url) {
    self._execCommand(self._getCommand(), self._getOptions(url))
  }

  this._getCommand = function () {
    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform]
  }

  this._getOptions = function (url) {
    return [url]
  }

  // Normalize the command, remove quotes (spawn does not like them).
  this._normalizeCommand = function (cmd) {
    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) &amp;&amp; '\'`"'.indexOf(cmd.charAt(0)) !== -1) {
      cmd = cmd.substring(1, cmd.length - 1)
      log.warn('The path should not be quoted.\n  Normalized the path to %s', cmd)
    }

    return path.normalize(cmd)
  }

  this._execCommand = function (cmd, args) {
    if (!cmd) {
      log.error('No binary for %s browser on your platform.\n  ' +
        'Please, set "%s" env variable.', self.name, self.ENV_CMD)

      // disable restarting
      self._retryLimit = -1

      return self._clearTempDirAndReportDone('no binary')
    }

    cmd = this._normalizeCommand(cmd)

    log.debug(cmd + ' ' + args.join(' '))
    self._process = spawn(cmd, args)

    var errorOutput = ''

    self._process.on('exit', function (code) {
      self._onProcessExit(code, errorOutput)
    })

    self._process.on('error', function (err) {
      if (err.code === 'ENOENT') {
        self._retryLimit = -1
        errorOutput = 'Can not find the binary ' + cmd + '\n\t' +
          'Please set env variable ' + self.ENV_CMD
      } else {
        errorOutput += err.toString()
      }
    })

    self._process.stderr.on('data', function (errBuff) {
      errorOutput += errBuff.toString()
    })
  }

  this._onProcessExit = function (code, errorOutput) {
    log.debug('Process %s exited with code %d', self.name, code)

    var error = null

    if (self.state === self.STATE_BEING_CAPTURED) {
      log.error('Cannot start %s\n\t%s', self.name, errorOutput)
      error = 'cannot start'
    }

    if (self.state === self.STATE_CAPTURED) {
      log.error('%s crashed.\n\t%s', self.name, errorOutput)
      error = 'crashed'
    }

    self._process = null
    if (self._killTimer) {
      timer.clearTimeout(self._killTimer)
      self._killTimer = null
    }
    self._clearTempDirAndReportDone(error)
  }

  this._clearTempDirAndReportDone = function (error) {
    tempDir.remove(self._tempDir, function () {
      self._done(error)
      if (onExitCallback) {
        onExitCallback()
        onExitCallback = null
      }
    })
  }

  this._onKillTimeout = function () {
    if (self.state !== self.STATE_BEING_KILLED &amp;&amp; self.state !== self.STATE_BEING_FORCE_KILLED) {
      return
    }

    log.warn('%s was not killed in %d ms, sending SIGKILL.', self.name, killTimeout)
    self._process.kill('SIGKILL')

    // NOTE: https://github.com/karma-runner/karma/pull/1184
    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.
    // If a process gets into a state where it doesn't respond in a reasonable amount of time
    // Karma should warn, and continue as though the kill succeeded.
    // This a certainly suboptimal, but it is better than having the test harness hang waiting
    // for a zombie child process to exit.
    self._killTimer = timer.setTimeout(function () {
      log.warn('%s was not killed by SIGKILL in %d ms, continuing.', self.name, killTimeout)
      self._onProcessExit(-1, '')
    }, killTimeout)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    process.exit(1)
}

return processArgs(argv, options, fs, path)
}

exports.run = function () {
var config = exports.<span class="apidocCodeKeywordSpan">process</span>()

switch (config.cmd) {
  case 'start':
    new Server(config).start()
    break
  case 'run':
    require('./runner').run(config)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.retry" id="apidoc.element.karma.retry">
        function <span class="apidocSignatureSpan">karma.</span>retry
        <span class="apidocSignatureSpan">(retryLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function (retryLimit) {
  var self = this

  this._retryLimit = retryLimit

  this.on('done', function () {
    if (!self.error) {
      return
    }

    if (self._retryLimit &gt; 0) {
      var attempt = retryLimit - self._retryLimit + 1
      log.info('Trying to start %s again (%d/%d).', self.name, attempt, retryLimit)
      self.restart()
      self._retryLimit--
    } else if (self._retryLimit === 0) {
      log.error('%s failed %d times (%s). Giving up.', self.name, retryLimit, self.error)
    } else {
      log.debug('%s failed (%s). Not restarting.', self.name, self.error)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.state_machine" id="apidoc.element.karma.state_machine">
        function <span class="apidocSignatureSpan">karma.</span>state_machine
        <span class="apidocSignatureSpan">(rli, colors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">state_machine = function (rli, colors) {
  var questions
  var currentQuestion
  var answers
  var currentOptions
  var currentOptionsPointer
  var currentQuestionId
  var done

  EventEmitter.call(this)

  var showPrompt = function () {
    rli.write(colors.ANSWER)
    rli.prompt()
  }

  this.onKeypress = function (key) {
    if (!currentOptions || !key) {
      return
    }

    if (key.name === 'tab' || key.name === 'right' || key.name === 'down') {
      this.suggestNextOption()
    } else if (key.name === 'left' || key.name === 'up') {
      currentOptionsPointer = currentOptionsPointer + currentOptions.length - 2
      this.suggestNextOption()
    }

    if (!key.ctrl &amp;&amp; !key.meta &amp;&amp; key.name !== 'enter' &amp;&amp; key.name !== 'return') {
      key.name = 'escape'
    }
  }

  this.suggestNextOption = function () {
    if (!currentOptions) {
      return
    }

    currentOptionsPointer = (currentOptionsPointer + 1) % currentOptions.length
    rli._deleteLineLeft()
    rli._deleteLineRight()
    rli.write(currentOptions[currentOptionsPointer])
  }

  this.kill = function () {
    currentOptions = null
    currentQuestionId = null
    rli.write('\n' + colors.RESET + '\n')
    rli.close()
  }

  this.onLine = function (line) {
    if (currentQuestionId) {
      rli.write(colors.RESET)
      line = line.trim().replace(colors.ANSWER, '').replace(colors.RESET, '')

      if (currentOptions) {
        currentOptionsPointer = currentOptions.indexOf(line)
        if (currentOptionsPointer === -1) {
          return
        }
      }

      if (line === '') {
        line = null
      }

      if (currentQuestion.boolean) {
        line = (line === 'yes' || line === 'true' || line === 'on')
      }

      if (line !== null &amp;&amp; currentQuestion.validate) {
        currentQuestion.validate(line)
      }

      if (currentQuestion.multiple) {
        answers[currentQuestionId] = answers[currentQuestionId] || []
        if (line !== null) {
          answers[currentQuestionId].push(line)
          showPrompt()

          if (currentOptions) {
            currentOptions.splice(currentOptionsPointer, 1)
            currentOptionsPointer = -1
          }
        } else {
          this.nextQuestion()
        }
      } else {
        answers[currentQuestionId] = line
        this.nextQuestion()
      }
    }
  }

  this.nextQuestion = function () {
    currentQuestion = questions.shift()

    while (currentQuestion &amp;&amp; currentQuestion.condition &amp;&amp; !currentQuestion.condition(answers)) {
      currentQuestion = questions.shift()
    }

    this.emit('next_question', currentQuestion)

    if (currentQuestion) {
      currentQuestionId = null

      rli.write('\n' + colors.question(currentQuestion.question) + '\n')
      rli.write(currentQuestion.hint + '\n')
      showPrompt()

      currentOptions = currentQuestion.options || null
      currentOptionsPointer = -1
      currentQuestionId = currentQuestion.id

      this.suggestNextOption()
    } else {
      currentQuestionId = null
      currentOptions = null

      // end
      this.kill()
      done(answers)
    }
  }

  this.process = function (_questions, _done) {
    questions = _questions
    answers = {}
    done = _done

    this.nextQuestion()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.url" id="apidoc.element.karma.url">
        function <span class="apidocSignatureSpan">karma.</span>url
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">url = function (path) {
  this.path = path
  this.isUrl = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server" id="apidoc.module.karma.Server">module karma.Server</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.Server" id="apidoc.element.karma.Server.Server">
        function <span class="apidocSignatureSpan">karma.</span>Server
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (cliOptions, done) {
  EventEmitter.call(this)

  logger.setupFromConfig(cliOptions)

  this.log = logger.create()

  this.loadErrors = []

  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)

  var modules = [{
    helper: ['value', helper],
    logger: ['value', logger],
    done: ['value', done || process.exit],
    emitter: ['value', this],
    server: ['value', this],
    launcher: ['type', Launcher],
    config: ['value', config],
    preprocess: ['factory', preprocessor.createPreprocessor],
    fileList: ['type', FileList],
    webServer: ['factory', ws.create],
    socketServer: ['factory', createSocketIoServer],
    executor: ['type', Executor],
    // TODO(vojta): remove
    customFileHandlers: ['value', []],
    // TODO(vojta): remove, once karma-dart does not rely on it
    customScriptTypes: ['value', []],
    reporter: ['factory', reporter.createReporters],
    capturedBrowsers: ['type', BrowserCollection],
    args: ['value', {}],
    timer: ['value', {
      setTimeout: function () {
        return setTimeout.apply(root, arguments)
      },
      clearTimeout: function (timeoutId) {
        clearTimeout(timeoutId)
      }
    }]
  }]

  this._setUpLoadErrorListener()
  // Load the plugins
  modules = modules.concat(plugin.resolve(config.plugins, this))

  this._injector = new di.Injector(modules)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.start" id="apidoc.element.karma.Server.start">
        function <span class="apidocSignatureSpan">karma.Server.</span>start
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cliOptions, done) {
  var server = new Server(cliOptions, done)
  server.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var UNIMPLEMENTED_START = function () {
  this.error('You need to include some adapter that implements __karma__.start method!')
}
// all files loaded, let's start the execution
this.loaded = function () {
  // has error -&gt; cancel
  if (!hasError) {
    this.<span class="apidocCodeKeywordSpan">start</span>(this.config)
  }

  // remove reference to child iframe
  this.start = UNIMPLEMENTED_START
}
// supposed to be overriden by the context
// TODO(vojta): support multiple callbacks (queue)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.super_" id="apidoc.element.karma.Server.super_">
        function <span class="apidocSignatureSpan">karma.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
    // TODO(vojta): allow passing args
    // TODO(vojta): ignore/throw if listener call done() multiple times
    var pending = this.listeners(name).length
    var deferred = helper.defer()
    var done = function () {
      if (!--pending) {
        deferred.resolve()
      }
    }

    this.emit(name, done)

    if (!pending) {
      deferred.resolve()
    }

    return deferred.promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server.prototype" id="apidoc.module.karma.Server.prototype">module karma.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.prototype._detach" id="apidoc.element.karma.Server.prototype._detach">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_detach
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_detach = function (config, done) {
  var log = this.log
  var tmpFile = tmp.fileSync({keep: true})
  log.info('Starting karma detached')
  log.info('Run "karma stop" to stop the server.')
  log.debug('Writing config to tmp-file %s', tmpFile.name)
  config.detached = false
  try {
    fs.writeFileSync(tmpFile.name, JSON.stringify(config), 'utf8')
  } catch (e) {
    log.error("Couldn't write temporary configuration file")
    done(1)
    return
  }
  var child = spawn(process.argv[0], [path.resolve(__dirname, '../lib/detached.js'), tmpFile.name], {
    detached: true,
    stdio: 'ignore'
  })
  child.unref()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype._setUpLoadErrorListener" id="apidoc.element.karma.Server.prototype._setUpLoadErrorListener">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_setUpLoadErrorListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setUpLoadErrorListener = function () {
  var self = this
  self.on('load_error', function (type, name) {
    self.log.debug('Registered a load error of type %s with name %s', type, name)
    self.loadErrors.push([type, name])
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype._start" id="apidoc.element.karma.Server.prototype._start">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_start
        <span class="apidocSignatureSpan">(config, launcher, preprocess, fileList, capturedBrowsers, executor, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_start = function (config, launcher, preprocess, fileList, capturedBrowsers, executor, done) {
  var self = this
  if (config.detached) {
    this._detach(config, done)
    return
  }

  self._fileList = fileList

  config.frameworks.forEach(function (framework) {
    self._injector.get('framework:' + framework)
  })

  var webServer = self._injector.get('webServer')
  var socketServer = self._injector.get('socketServer')

  // A map of launched browsers.
  var singleRunDoneBrowsers = Object.create(null)

  // Passing fake event emitter, so that it does not emit on the global,
  // we don't care about these changes.
  var singleRunBrowsers = new BrowserCollection(new EventEmitter())

  // Some browsers did not get captured.
  var singleRunBrowserNotCaptured = false

  webServer.on('error', function (e) {
    if (e.code === 'EADDRINUSE') {
      self.log.warn('Port %d in use', config.port)
      config.port++
      webServer.listen(config.port, config.listenAddress)
    } else {
      throw e
    }
  })

  var afterPreprocess = function () {
    if (config.autoWatch) {
      self._injector.invoke(watcher.watch)
    }

    webServer.listen(config.port, config.listenAddress, function () {
      self.log.info('Karma v%s server started at %s//%s:%s%s', constant.VERSION,
        config.protocol, config.listenAddress, config.port, config.urlRoot)

      self.emit('listening', config.port)
      if (config.browsers &amp;&amp; config.browsers.length) {
        self._injector.invoke(launcher.launch, launcher).forEach(function (browserLauncher) {
          singleRunDoneBrowsers[browserLauncher.id] = false
        })
      }
      var noLoadErrors = self.loadErrors.length
      if (noLoadErrors &gt; 0) {
        self.log.error('Found %d load error%s', noLoadErrors, noLoadErrors === 1 ? '' : 's')
        process.exitCode = 1
        process.kill(process.pid, 'SIGINT')
      }
    })
  }

  fileList.refresh().then(afterPreprocess, afterPreprocess)

  self.on('browsers_change', function () {
    // TODO(vojta): send only to interested browsers
    socketServer.sockets.emit('info', capturedBrowsers.serialize())
  })

  self.on('browser_register', function (browser) {
    launcher.markCaptured(browser.id)

    // TODO(vojta): This is lame, browser can get captured and then
    // crash (before other browsers get captured).
    if (launcher.areAllCaptured()) {
      self.emit('browsers_ready')

      if (config.autoWatch) {
        executor.schedule()
      }
    }
  })

  if (config.browserConsoleLogOptions &amp;&amp; config.browserConsoleLogOptions.path) {
    var configLevel = config.browserConsoleLogOptions.level || 'debug'
    var configFormat = config.browserConsoleLogOptions.format || '%b %T: %m'
    var configPath = config.browserConsoleLogOptions.path
    self.log.info('Writing browser console to file: %s', configPath)
    var browserLogFile = fs.openSync(configPath, 'w+')
    var levels = ['log', 'error', 'warn', 'info', 'debug']
    self.on('browser_log', function (browser, message, level) {
      if (levels.indexOf(level.toLowerCase()) &gt; levels.indexOf(configLevel)) return
      if (!helper.isString(message)) {
        message = util.inspect(message, {showHidden: false, colors: false})
      }
      var logMap = {'%m': message, '%t': level.toLowerCase(), '%T': level.toUpperCase(), '%b': browser}
      var logString = configFormat.replace(/%[mtTb]/g, function (m) {
        return logMap[m]
      })
      self.log.debug('Writing browser console line: %s', logString)
      fs.write(browserLogFile, logString + '\n')
    })
  }

  var EVENTS_TO_REPLY = ['start', 'info', 'karma_error', 'result', 'complete']
  socketServer.sockets.on('connection', function (socket) {
    self.log.debug('A browser has connected on socket ' + socket.id)

    var replySocketEvents = events.bufferEvents(socket, EVENTS_TO_REPLY)

    socket.on('complete', function (data, ack) {
      ack()
    })

    socket.on('register', function (info) {
      var newBrowser
      var isRestart

      if (info.id) {
        newBrowser = capturedBrowsers.getById ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var onExitCallback
var killTimeout = processKillTimeout || 2000

this._tempDir = tempDir.getPath('/karma-' + this.id.toString())

this.on('start', function (url) {
  tempDir.create(self._tempDir)
  self.<span class="apidocCodeKeywordSpan">_start</span>(url)
})

this.on('kill', function (done) {
  if (!self._process) {
    return process.nextTick(done)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.get" id="apidoc.element.karma.Server.prototype.get">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>get
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (token) {
  return this._injector.get(token)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var token = type + ':' + definition.base
  var locals = {
    args: ['value', definition]
  }

  module[type + ':' + name] = ['factory', function (injector) {
    var plugin = injector.createChild([locals], [token]).<span class="apidocCodeKeywordSpan">get</span>(token)
    if (type === 'launcher' &amp;&amp; helper.isDefined(definition.displayName)) {
      plugin.displayName = definition.displayName
    }
    return plugin
  }]
  hasSomeInlinedPlugin = true
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.refreshFiles" id="apidoc.element.karma.Server.prototype.refreshFiles">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>refreshFiles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshFiles = function () {
  if (!this._fileList) return Promise.resolve()

  return this._fileList.refresh()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.start" id="apidoc.element.karma.Server.prototype.start">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  this._injector.invoke(this._start, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var UNIMPLEMENTED_START = function () {
  this.error('You need to include some adapter that implements __karma__.start method!')
}
// all files loaded, let's start the execution
this.loaded = function () {
  // has error -&gt; cancel
  if (!hasError) {
    this.<span class="apidocCodeKeywordSpan">start</span>(this.config)
  }

  // remove reference to child iframe
  this.start = UNIMPLEMENTED_START
}
// supposed to be overriden by the context
// TODO(vojta): support multiple callbacks (queue)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server.super_" id="apidoc.module.karma.Server.super_">module karma.Server.super_</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.super_.super_" id="apidoc.element.karma.Server.super_.super_">
        function <span class="apidocSignatureSpan">karma.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.base" id="apidoc.module.karma.base">module karma.base</a></h1>


    <h2>
        <a href="#apidoc.element.karma.base.base" id="apidoc.element.karma.base.base">
        function <span class="apidocSignatureSpan">karma.</span>base
        <span class="apidocSignatureSpan">(id, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">base = function (id, emitter) {
  if (this.start) {
    return
  }

  // TODO(vojta): figure out how to do inheritance with DI
  Object.keys(EventEmitter.prototype).forEach(function (method) {
    this[method] = EventEmitter.prototype[method]
  }, this)
  KarmaEventEmitter.call(this)

  this.id = id
  this.state = null
  this.error = null

  var self = this
  var killingPromise
  var previousUrl

  this.start = function (url) {
    previousUrl = url

    this.error = null
    this.state = BEING_CAPTURED
    this.emit('start', url + '?id=' + this.id + (helper.isDefined(self.displayName) ? '&amp;displayName=' + encodeURIComponent(self.
displayName) : ''))
  }

  this.kill = function () {
    // Already killed, or being killed.
    if (killingPromise) {
      return killingPromise
    }

    killingPromise = this.emitAsync('kill').then(function () {
      self.state = FINISHED
    })

    this.state = BEING_KILLED

    return killingPromise
  }

  this.forceKill = function () {
    this.kill()
    this.state = BEING_FORCE_KILLED

    return killingPromise
  }

  this.restart = function () {
    if (this.state === BEING_FORCE_KILLED) {
      return
    }

    if (!killingPromise) {
      killingPromise = this.emitAsync('kill')
    }

    killingPromise.then(function () {
      if (self.state === BEING_FORCE_KILLED) {
        self.state = FINISHED
      } else {
        killingPromise = null
        log.debug('Restarting %s', self.name)
        self.start(previousUrl)
      }
    })

    self.state = RESTARTING
  }

  this.markCaptured = function () {
    if (this.state === BEING_CAPTURED) {
      this.state = CAPTURED
    }
  }

  this.isCaptured = function () {
    return this.state === CAPTURED
  }

  this.toString = function () {
    return this.name
  }

  this._done = function (error) {
    killingPromise = killingPromise || Promise.resolve()

    this.error = this.error || error
    this.emit('done')

    if (this.error &amp;&amp; this.state !== BEING_FORCE_KILLED &amp;&amp; this.state !== RESTARTING) {
      emitter.emit('browser_process_failure', this)
    }

    this.state = FINISHED
  }

  this.STATE_BEING_CAPTURED = BEING_CAPTURED
  this.STATE_CAPTURED = CAPTURED
  this.STATE_BEING_KILLED = BEING_KILLED
  this.STATE_FINISHED = FINISHED
  this.STATE_RESTARTING = RESTARTING
  this.STATE_BEING_FORCE_KILLED = BEING_FORCE_KILLED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.base.decoratorFactory" id="apidoc.element.karma.base.decoratorFactory">
        function <span class="apidocSignatureSpan">karma.base.</span>decoratorFactory
        <span class="apidocSignatureSpan">(id, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decoratorFactory = function (id, emitter) {
  return function (launcher) {
    BaseLauncher.call(launcher, id, emitter)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.capture_timeout" id="apidoc.module.karma.capture_timeout">module karma.capture_timeout</a></h1>


    <h2>
        <a href="#apidoc.element.karma.capture_timeout.capture_timeout" id="apidoc.element.karma.capture_timeout.capture_timeout">
        function <span class="apidocSignatureSpan">karma.</span>capture_timeout
        <span class="apidocSignatureSpan">(timer, captureTimeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">capture_timeout = function (timer, captureTimeout) {
  if (!captureTimeout) {
    return
  }

  var self = this
  var pendingTimeoutId = null

  this.on('start', function () {
    pendingTimeoutId = timer.setTimeout(function () {
      pendingTimeoutId = null
      if (self.state !== self.STATE_BEING_CAPTURED) {
        return
      }

      log.warn('%s have not captured in %d ms, killing.', self.name, captureTimeout)
      self.error = 'timeout'
      self.kill()
    }, captureTimeout)
  })

  this.on('done', function () {
    if (pendingTimeoutId) {
      timer.clearTimeout(pendingTimeoutId)
      pendingTimeoutId = null
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.capture_timeout.decoratorFactory" id="apidoc.element.karma.capture_timeout.decoratorFactory">
        function <span class="apidocSignatureSpan">karma.capture_timeout.</span>decoratorFactory
        <span class="apidocSignatureSpan">(timer, captureTimeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decoratorFactory = function (timer, captureTimeout) {
  return function (launcher) {
    CaptureTimeoutLauncher.call(launcher, timer, captureTimeout)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.cli" id="apidoc.module.karma.cli">module karma.cli</a></h1>


    <h2>
        <a href="#apidoc.element.karma.cli.argsBeforeDoubleDash" id="apidoc.element.karma.cli.argsBeforeDoubleDash">
        function <span class="apidocSignatureSpan">karma.cli.</span>argsBeforeDoubleDash
        <span class="apidocSignatureSpan">(argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">argsBeforeDoubleDash = function (argv) {
  var idx = argv.indexOf('--')

  return idx === -1 ? argv : argv.slice(0, idx)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.cli.parseClientArgs" id="apidoc.element.karma.cli.parseClientArgs">
        function <span class="apidocSignatureSpan">karma.cli.</span>parseClientArgs
        <span class="apidocSignatureSpan">(argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClientArgs = function (argv) {
  // extract any args after '--' as clientArgs
  var clientArgs = []
  argv = argv.slice(2)
  var idx = argv.indexOf('--')
  if (idx !== -1) {
    clientArgs = argv.slice(idx + 1)
  }
  return clientArgs
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.cli.process" id="apidoc.element.karma.cli.process">
        function <span class="apidocSignatureSpan">karma.cli.</span>process
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function () {
  var argv = optimist.parse(argsBeforeDoubleDash(process.argv.slice(2)))
  var options = {
    cmd: argv._.shift()
  }

  switch (options.cmd) {
    case 'start':
      describeStart()
      break

    case 'run':
      describeRun()
      options.clientArgs = parseClientArgs(process.argv)
      break

    case 'stop':
      describeStop()
      break

    case 'init':
      describeInit()
      break

    case 'completion':
      describeCompletion()
      break

    default:
      describeShared()
      if (!options.cmd) {
        processArgs(argv, options, fs, path)
        console.error('Command not specified.')
      } else {
        console.error('Unknown command "' + options.cmd + '".')
      }
      optimist.showHelp()
      process.exit(1)
  }

  return processArgs(argv, options, fs, path)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    process.exit(1)
}

return processArgs(argv, options, fs, path)
}

exports.run = function () {
var config = exports.<span class="apidocCodeKeywordSpan">process</span>()

switch (config.cmd) {
  case 'start':
    new Server(config).start()
    break
  case 'run':
    require('./runner').run(config)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.cli.processArgs" id="apidoc.element.karma.cli.processArgs">
        function <span class="apidocSignatureSpan">karma.cli.</span>processArgs
        <span class="apidocSignatureSpan">(argv, options, fs, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processArgs = function (argv, options, fs, path) {
  if (argv.help) {
    console.log(optimist.help())
    process.exit(0)
  }

  if (argv.version) {
    console.log('Karma version: ' + constant.VERSION)
    process.exit(0)
  }

  // TODO(vojta): warn/throw when unknown argument (probably mispelled)
  Object.getOwnPropertyNames(argv).forEach(function (name) {
    var argumentValue = argv[name]
    if (name !== '_' &amp;&amp; name !== '$0') {
      if (Array.isArray(argumentValue)) {
        // If the same argument is defined multiple times, override.
        argumentValue = argumentValue.pop()
      }
      options[helper.dashToCamel(name)] = argumentValue
    }
  })

  if (helper.isString(options.autoWatch)) {
    options.autoWatch = options.autoWatch === 'true'
  }

  if (helper.isString(options.colors)) {
    options.colors = options.colors === 'true'
  }

  if (helper.isString(options.failOnEmptyTestSuite)) {
    options.failOnEmptyTestSuite = options.failOnEmptyTestSuite === 'true'
  }

  if (helper.isString(options.formatError)) {
    try {
      var required = require(options.formatError)
    } catch (err) {
      console.error('Could not require formatError: ' + options.formatError, err)
    }
    // support exports.formatError and module.exports = function
    options.formatError = required.formatError || required
    if (!helper.isFunction(options.formatError)) {
      console.error('Format error must be a function, got: ' + typeof options.formatError)
      process.exit(1)
    }
  }

  if (helper.isString(options.logLevel)) {
    var logConstant = constant['LOG_' + options.logLevel.toUpperCase()]
    if (helper.isDefined(logConstant)) {
      options.logLevel = logConstant
    } else {
      console.error('Log level must be one of disable, error, warn, info, or debug.')
      process.exit(1)
    }
  } else if (helper.isDefined(options.logLevel)) {
    console.error('Log level must be one of disable, error, warn, info, or debug.')
    process.exit(1)
  }

  if (helper.isString(options.singleRun)) {
    options.singleRun = options.singleRun === 'true'
  }

  if (helper.isString(options.browsers)) {
    options.browsers = options.browsers.split(',')
  }

  if (options.reportSlowerThan === false) {
    options.reportSlowerThan = 0
  }

  if (helper.isString(options.reporters)) {
    options.reporters = options.reporters.split(',')
  }

  if (helper.isString(options.removedFiles)) {
    options.removedFiles = options.removedFiles.split(',')
  }

  if (helper.isString(options.addedFiles)) {
    options.addedFiles = options.addedFiles.split(',')
  }

  if (helper.isString(options.changedFiles)) {
    options.changedFiles = options.changedFiles.split(',')
  }

  if (helper.isString(options.refresh)) {
    options.refresh = options.refresh === 'true'
  }

  var configFile = argv._.shift()

  if (!configFile) {
    // default config file (if exists)
    if (fs.existsSync('./karma.conf.js')) {
      configFile = './karma.conf.js'
    } else if (fs.existsSync('./karma.conf.coffee')) {
      configFile = './karma.conf.coffee'
    } else if (fs.existsSync('./karma.conf.ts')) {
      configFile = './karma.conf.ts'
    } else if (fs.existsSync('./.config/karma.conf.js')) {
      configFile = './.config/karma.conf.js'
    } else if (fs.existsSync('./.config/karma.conf.coffee')) {
      configFile = './.config/karma.conf.coffee'
    } else if (fs.existsSync('./.config/karma.conf.ts')) {
      configFile = './.config/karma.conf.ts'
    }
  }

  options.configFile = configFile ? path.resolve(configFile) : null

  return options
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.cli.run" id="apidoc.element.karma.cli.run">
        function <span class="apidocSignatureSpan">karma.cli.</span>run
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function () {
  var config = exports.process()

  switch (config.cmd) {
    case 'start':
      new Server(config).start()
      break
    case 'run':
      require('./runner').run(config)
      break
    case 'stop':
      require('./stopper').stop(config)
      break
    case 'init':
      require('./init').init(config)
      break
    case 'completion':
      require('./completion').completion(config)
      break
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
require('load-grunt-tasks')(grunt)

grunt.registerTask('build', ['browserify:client'])
grunt.registerTask('default', ['build', 'test', 'lint'])
grunt.registerTask('test-appveyor', ['test:unit', 'test:client'])

grunt.registerTask('release', 'Build, bump and publish to NPM.', function (type) {
  grunt.task.<span class="apidocCodeKeywordSpan">run</span>([
    'npm-contributors',
    'bump:' + (type || 'patch') + ':bump-only',
    'build',
    'conventionalChangelog',
    'bump-commit',
    'conventionalGithubReleaser',
    'npm-publish'
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.common" id="apidoc.module.karma.common">module karma.common</a></h1>


    <h2>
        <a href="#apidoc.element.karma.common.PromiseContainer" id="apidoc.element.karma.common.PromiseContainer">
        function <span class="apidocSignatureSpan">karma.common.</span>PromiseContainer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PromiseContainer = function () {
  var promise

  this.then = function (success, error) {
    error = error || _.noop
    return promise.then(success).catch(error)
  }

  this.set = function (newPromise) {
    promise = newPromise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
createCustomHandler.$inject = ['customFileHandlers', 'config.basePath']

var createWebServer = function (injector, emitter, fileList) {
var config = injector.get('config')
common.initializeMimeTypes(config)
var serveStaticFile = common.createServeFile(fs, path.normalize(path.join(__dirname, '/../static')), config)
var serveFile = common.createServeFile(fs, null, config)
var filesPromise = new common.<span class="apidocCodeKeywordSpan">PromiseContainer</span>()

// Set an empty list of files to avoid race issues with
// file_list_modified not having been emitted yet
filesPromise.set(Promise.resolve(fileList.files))

emitter.on('file_list_modified', function (files) {
  filesPromise.set(Promise.resolve(files))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.common.createServeFile" id="apidoc.element.karma.common.createServeFile">
        function <span class="apidocSignatureSpan">karma.common.</span>createServeFile
        <span class="apidocSignatureSpan">(fs, directory, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createServeFile = function (fs, directory, config) {
  var cache = Object.create(null)

  return function (filepath, rangeHeader, response, transform, content, doNotCache) {
    var responseData

    var convertForRangeRequest = function () {
      var range = parseRange(responseData.length, rangeHeader)
      if (range === -2) {
        // malformed header string
        return 200
      } else if (range === -1) {
        // unsatisfiable range
        responseData = Buffer.alloc(0)
        return 416
      } else if (range.type === 'bytes') {
        responseData = Buffer.from(responseData)
        if (range.length === 1) {
          var start = range[0].start
          var end = range[0].end
          response.setHeader(
            'Content-Range',
            'bytes ' + start + '-' + end + '/' + responseData.length
          )
          response.setHeader('Accept-Ranges', 'bytes')
          response.setHeader('Content-Length', end - start + 1)
          responseData = responseData.slice(start, end + 1)
          return 206
        } else {
          // Multiple ranges are not supported. Maybe future?
          responseData = new Buffer(0)
          return 416
        }
      }
      // All other states, ignore
      return 200
    }

    if (directory) {
      filepath = directory + filepath
    }

    if (!content &amp;&amp; cache[filepath]) {
      content = cache[filepath]
    }

    if (config &amp;&amp; config.customHeaders &amp;&amp; config.customHeaders.length &gt; 0) {
      config.customHeaders.forEach(function (header) {
        var regex = new RegExp(header.match)
        if (regex.test(filepath)) {
          log.debug('setting header: ' + header.name + ' for: ' + filepath)
          response.setHeader(header.name, header.value)
        }
      })
    }

    // serve from cache
    if (content &amp;&amp; !doNotCache) {
      response.setHeader('Content-Type', mime.lookup(filepath, 'text/plain'))

      // call custom transform fn to transform the data
      responseData = (transform &amp;&amp; transform(content)) || content

      if (rangeHeader) {
        var code = convertForRangeRequest()
        response.writeHead(code)
      } else {
        response.writeHead(200)
      }

      log.debug('serving (cached): ' + filepath)
      return response.end(responseData)
    }

    return fs.readFile(filepath, function (error, data) {
      if (error) {
        return serve404(response, filepath)
      }

      if (!doNotCache) {
        cache[filepath] = data.toString()
      }

      response.setHeader('Content-Type', mime.lookup(filepath, 'text/plain'))

      // call custom transform fn to transform the data
      responseData = (transform &amp;&amp; transform(data.toString())) || data

      if (rangeHeader) {
        var code = convertForRangeRequest()
        response.writeHead(code)
      } else {
        response.writeHead(200)
      }

      log.debug('serving: ' + filepath)
      return response.end(responseData)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

createCustomHandler.$inject = ['customFileHandlers', 'config.basePath']

var createWebServer = function (injector, emitter, fileList) {
var config = injector.get('config')
common.initializeMimeTypes(config)
var serveStaticFile = common.<span class="apidocCodeKeywordSpan">createServeFile</span>(fs, path.normalize(path.join(__dirname, &amp;#
x27;/../static')), config)
var serveFile = common.createServeFile(fs, null, config)
var filesPromise = new common.PromiseContainer()

// Set an empty list of files to avoid race issues with
// file_list_modified not having been emitted yet
filesPromise.set(Promise.resolve(fileList.files))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.common.initializeMimeTypes" id="apidoc.element.karma.common.initializeMimeTypes">
        function <span class="apidocSignatureSpan">karma.common.</span>initializeMimeTypes
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initializeMimeTypes = function (config) {
  if (config &amp;&amp; config.mime) {
    _.forEach(config.mime, function (value, key) {
      var map = {}
      map[key] = value
      mime.define(map)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}

createCustomHandler.$inject = ['customFileHandlers', 'config.basePath']

var createWebServer = function (injector, emitter, fileList) {
var config = injector.get('config')
common.<span class="apidocCodeKeywordSpan">initializeMimeTypes</span>(config)
var serveStaticFile = common.createServeFile(fs, path.normalize(path.join(__dirname, '/../static')), config)
var serveFile = common.createServeFile(fs, null, config)
var filesPromise = new common.PromiseContainer()

// Set an empty list of files to avoid race issues with
// file_list_modified not having been emitted yet
filesPromise.set(Promise.resolve(fileList.files))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.common.serve404" id="apidoc.element.karma.common.serve404">
        function <span class="apidocSignatureSpan">karma.common.</span>serve404
        <span class="apidocSignatureSpan">(response, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serve404 = function (response, path) {
  log.warn('404: ' + path)
  response.writeHead(404)
  return response.end('NOT FOUND')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (config.middleware) {
  config.middleware.forEach(function (middleware) {
    handler.use(injector.get('middleware:' + middleware))
  })
}

handler.use(function (request, response) {
  common.<span class="apidocCodeKeywordSpan">serve404</span>(response, request.url)
})

var serverClass = http
var serverArguments = [handler]

if (config.protocol === 'https:') {
  serverClass = https
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.common.setHeavyCacheHeaders" id="apidoc.element.karma.common.setHeavyCacheHeaders">
        function <span class="apidocSignatureSpan">karma.common.</span>setHeavyCacheHeaders
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHeavyCacheHeaders = function (response) {
  response.setHeader('Cache-Control', 'public, max-age=31536000')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           findByPath(files.served, requestedFilePathUnescaped)
var rangeHeader = request.headers['range']

if (file) {
  serveFile(file.contentPath || file.path, rangeHeader, response, function () {
    if (/\?\w+/.test(request.url)) {
      // files with timestamps - cache one year, rely on timestamps
      common.<span class="apidocCodeKeywordSpan">setHeavyCacheHeaders</span>(response)
    } else {
      // without timestamps - no cache (debug)
      common.setNoCacheHeaders(response)
    }
  }, file.content, file.doNotCache)
} else {
  next()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.common.setNoCacheHeaders" id="apidoc.element.karma.common.setNoCacheHeaders">
        function <span class="apidocSignatureSpan">karma.common.</span>setNoCacheHeaders
        <span class="apidocSignatureSpan">(response)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setNoCacheHeaders = function (response) {
  response.setHeader('Cache-Control', 'no-cache')
  response.setHeader('Pragma', 'no-cache')
  response.setHeader('Expires', (new Date(0)).toUTCString())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (file) {
  serveFile(file.contentPath || file.path, rangeHeader, response, function () {
    if (/\?\w+/.test(request.url)) {
      // files with timestamps - cache one year, rely on timestamps
      common.setHeavyCacheHeaders(response)
    } else {
      // without timestamps - no cache (debug)
      common.<span class="apidocCodeKeywordSpan">setNoCacheHeaders</span>(response)
    }
  }, file.content, file.doNotCache)
} else {
  next()
}

request.resume()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.completion" id="apidoc.module.karma.completion">module karma.completion</a></h1>


    <h2>
        <a href="#apidoc.element.karma.completion.completion" id="apidoc.element.karma.completion.completion">
        function <span class="apidocSignatureSpan">karma.</span>completion
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function () {
  if (process.argv[3] === '--') {
    return complete(parseEnv(process.argv, process.env))
  }

  // just print out the karma-completion.sh
  var fs = require('graceful-fs')
  var path = require('path')

  fs.readFile(path.resolve(__dirname, '../scripts/karma-completion.sh'), 'utf8', function (err, data) {
    if (err) return console.error(err)

    process.stdout.write(data)
    process.stdout.on('error', function (error) {
      // Darwin is a real dick sometimes.
      //
      // This is necessary because the "source" or "." program in
      // bash on OS X closes its file argument before reading
      // from it, meaning that you get exactly 1 write, which will
      // work most of the time, and will always raise an EPIPE.
      //
      // Really, one should not be tossing away EPIPE errors, or any
      // errors, so casually.  But, without this, `. &lt;(karma completion)`
      // can never ever work on OS X.
      if (error.errno === 'EPIPE') {
        error = null
      }
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'stop':
      require('./stopper').stop(config)
      break
    case 'init':
      require('./init').init(config)
      break
    case 'completion':
      require('./completion').<span class="apidocCodeKeywordSpan">completion</span>(config)
      break
  }
}

// just for testing
exports.processArgs = processArgs
exports.parseClientArgs = parseClientArgs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.completion.complete" id="apidoc.element.karma.completion.complete">
        function <span class="apidocSignatureSpan">karma.completion.</span>complete
        <span class="apidocSignatureSpan">(env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function (env) {
  if (env.count === 1) {
    if (env.words[0].charAt(0) === '-') {
      return sendCompletion(['--help', '--version'], env)
    }

    return sendCompletion(Object.keys(options), env)
  }

  if (env.count === 2 &amp;&amp; env.words[1].charAt(0) !== '-') {
    // complete files (probably karma.conf.js)
    return sendCompletionFiles(env)
  }

  var cmdOptions = options[env.words[0]]
  var previousOption = cmdOptions[env.prev]

  if (!cmdOptions) {
    // no completion, wrong command
    return sendCompletionNoOptions()
  }

  if (previousOption === CUSTOM &amp;&amp; env.last) {
    // custom value with already filled something
    return sendCompletionConfirmLast(env)
  }

  if (previousOption) {
    // custom options
    return sendCompletion(previousOption, env)
  }

  return sendCompletion(Object.keys(cmdOptions), env)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.completion.opositeWord" id="apidoc.element.karma.completion.opositeWord">
        function <span class="apidocSignatureSpan">karma.completion.</span>opositeWord
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">opositeWord = function (word) {
  if (word.charAt(0) !== '-') {
    return null
  }

  return word.substr(0, 5) === '--no-' ? '--' + word.substr(5) : '--no-' + word.substr(2)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.completion.sendCompletion" id="apidoc.element.karma.completion.sendCompletion">
        function <span class="apidocSignatureSpan">karma.completion.</span>sendCompletion
        <span class="apidocSignatureSpan">(possibleWords, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendCompletion = function (possibleWords, env) {
  var regexp = new RegExp('^' + env.last)
  var filteredWords = possibleWords.filter(function (word) {
    return regexp.test(word) &amp;&amp; env.words.indexOf(word) === -1 &amp;&amp;
      env.words.indexOf(opositeWord(word)) === -1
  })

  if (!filteredWords.length) {
    return sendCompletionNoOptions(env)
  }

  filteredWords.forEach(function (word) {
    console.log(word)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.config" id="apidoc.module.karma.config">module karma.config</a></h1>


    <h2>
        <a href="#apidoc.element.karma.config.parseConfig" id="apidoc.element.karma.config.parseConfig">
        function <span class="apidocSignatureSpan">karma.config.</span>parseConfig
        <span class="apidocSignatureSpan">(configFilePath, cliOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseConfig = function (configFilePath, cliOptions) {
  var configModule
  if (configFilePath) {
    log.debug('Loading config %s', configFilePath)

    try {
      configModule = require(configFilePath)
      if (typeof configModule === 'object' &amp;&amp; typeof configModule.default !== 'undefined') {
        configModule = configModule.default
      }
    } catch (e) {
      if (e.code === 'MODULE_NOT_FOUND' &amp;&amp; e.message.indexOf(configFilePath) !== -1) {
        log.error('File %s does not exist!', configFilePath)
      } else {
        log.error('Invalid config file!\n  ' + e.stack)

        var extension = path.extname(configFilePath)
        if (extension === '.coffee' &amp;&amp; !COFFEE_SCRIPT_AVAILABLE) {
          log.error('You need to install CoffeeScript.\n' +
            '  npm install coffee-script --save-dev')
        } else if (extension === '.ls' &amp;&amp; !LIVE_SCRIPT_AVAILABLE) {
          log.error('You need to install LiveScript.\n' +
            '  npm install LiveScript --save-dev')
        } else if (extension === '.ts' &amp;&amp; !TYPE_SCRIPT_AVAILABLE) {
          log.error('You need to install TypeScript.\n' +
            '  npm install typescript ts-node --save-dev')
        }
      }
      return process.exit(1)
    }
    if (!helper.isFunction(configModule)) {
      log.error('Config file must export a function!\n' + CONFIG_SYNTAX_HELP)
      return process.exit(1)
    }
  } else {
    log.debug('No config file specified.')
    // if no config file path is passed, we define a dummy config module.
    configModule = function () {}
  }

  var config = new Config()

  // save and reset hostname and listenAddress so we can detect if the user
  // changed them
  var defaultHostname = config.hostname
  config.hostname = null
  var defaultListenAddress = config.listenAddress
  config.listenAddress = null

  // add the user's configuration in
  config.set(cliOptions)

  try {
    configModule(config)
  } catch (e) {
    log.error('Error in config file!\n', e)
    return process.exit(1)
  }

  // merge the config from config file and cliOptions (precedence)
  config.set(cliOptions)

  // if the user changed listenAddress, but didn't set a hostname, warn them
  if (config.hostname === null &amp;&amp; config.listenAddress !== null) {
    log.warn('ListenAddress was set to %s but hostname was left as the default: ' +
      '%s. If your browsers fail to connect, consider changing the hostname option.',
      config.listenAddress, defaultHostname)
  }
  // restore values that weren't overwritten by the user
  if (config.hostname === null) {
    config.hostname = defaultHostname
  }
  if (config.listenAddress === null) {
    config.listenAddress = defaultListenAddress
  }

  // configure the logger as soon as we can
  logger.setup(config.logLevel, config.colors, config.loggers)

  return normalizeConfig(config, configFilePath)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.emitter_wrapper" id="apidoc.module.karma.emitter_wrapper">module karma.emitter_wrapper</a></h1>


    <h2>
        <a href="#apidoc.element.karma.emitter_wrapper.emitter_wrapper" id="apidoc.element.karma.emitter_wrapper.emitter_wrapper">
        function <span class="apidocSignatureSpan">karma.</span>emitter_wrapper
        <span class="apidocSignatureSpan">(emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EmitterWrapper(emitter) {
  this.listeners = {}
  this.emitter = emitter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.emitter_wrapper.prototype" id="apidoc.module.karma.emitter_wrapper.prototype">module karma.emitter_wrapper.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.karma.emitter_wrapper.prototype.addListener" id="apidoc.element.karma.emitter_wrapper.prototype.addListener">
        function <span class="apidocSignatureSpan">karma.emitter_wrapper.prototype.</span>addListener
        <span class="apidocSignatureSpan">(event, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function (event, listener) {
  this.emitter.addListener(event, listener)

  if (!this.listeners.hasOwnProperty(event)) {
    this.listeners[event] = []
  }

  this.listeners[event].push(listener)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function EmitterWrapper (emitter) {
this.listeners = {}
this.emitter = emitter
}

EmitterWrapper.prototype.addListener = EmitterWrapper.prototype.on = function (event, listener) {
this.emitter.<span class="apidocCodeKeywordSpan">addListener</span>(event, listener)

if (!this.listeners.hasOwnProperty(event)) {
  this.listeners[event] = []
}

this.listeners[event].push(listener)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.emitter_wrapper.prototype.on" id="apidoc.element.karma.emitter_wrapper.prototype.on">
        function <span class="apidocSignatureSpan">karma.emitter_wrapper.prototype.</span>on
        <span class="apidocSignatureSpan">(event, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (event, listener) {
  this.emitter.addListener(event, listener)

  if (!this.listeners.hasOwnProperty(event)) {
    this.listeners[event] = []
  }

  this.listeners[event].push(listener)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})
    },

    bootstrap: function (w) {
var path = require('path')
var mocha = w.testFramework

mocha.suite.<span class="apidocCodeKeywordSpan">on</span>('pre-require', function () {
  // always passing wallaby.js globals to mocks.loadFile
  var mocks = require('mocks')
  var loadFile = mocks.loadFile
  mocks.loadFile = function (filePath, mocks, globals, mockNested) {
    mocks = mocks || {}
    globals = globals || {}
    globals.$_$wp = global.$_$wp || {}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.emitter_wrapper.prototype.removeAllListeners" id="apidoc.element.karma.emitter_wrapper.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">karma.emitter_wrapper.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function (event) {
  var events = event ? [event] : Object.keys(this.listeners)
  var self = this
  events.forEach(function (event) {
    self.listeners[event].forEach(function (listener) {
      self.emitter.removeListener(event, listener)
    })
    delete self.listeners[event]
  })

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.events" id="apidoc.module.karma.events">module karma.events</a></h1>


    <h2>
        <a href="#apidoc.element.karma.events.EventEmitter" id="apidoc.element.karma.events.EventEmitter">
        function <span class="apidocSignatureSpan">karma.events.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EventEmitter = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
    // TODO(vojta): allow passing args
    // TODO(vojta): ignore/throw if listener call done() multiple times
    var pending = this.listeners(name).length
    var deferred = helper.defer()
    var done = function () {
      if (!--pending) {
        deferred.resolve()
      }
    }

    this.emit(name, done)

    if (!pending) {
      deferred.resolve()
    }

    return deferred.promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.events.bindAll" id="apidoc.element.karma.events.bindAll">
        function <span class="apidocSignatureSpan">karma.events.</span>bindAll
        <span class="apidocSignatureSpan">(object, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindAll = function (object, context) {
  context = context || this

  var bindMethod = function (method) {
    context.on(helper.camelToSnake(method.substr(2)), function () {
      var args = Array.prototype.slice.call(arguments, 0)
      args.push(context)
      object[method].apply(object, args)
    })
  }

  for (var method in object) {
    if (helper.isFunction(object[method]) &amp;&amp; method.substr(0, 2) === 'on') {
      bindMethod(method)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.state = READY
  this.lastResult = new Result()
  this.disconnectsCount = 0

  this.init = function () {
collection.add(this)

events.<span class="apidocCodeKeywordSpan">bindAll</span>(this, socket)

log.info('Connected on socket %s with id %s', socket.id, id)

// TODO(vojta): move to collection
emitter.emit('browsers_change', collection)

emitter.emit('browser_register', this)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.events.bufferEvents" id="apidoc.element.karma.events.bufferEvents">
        function <span class="apidocSignatureSpan">karma.events.</span>bufferEvents
        <span class="apidocSignatureSpan">(emitter, eventsToBuffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bufferEvents = function (emitter, eventsToBuffer) {
  var listeners = []
  var eventsToReply = []
  var genericListener = function () {
    eventsToReply.push(Array.prototype.slice.call(arguments))
  }

  eventsToBuffer.forEach(function (eventName) {
    var listener = genericListener.bind(null, eventName)
    listeners.push(listener)
    emitter.on(eventName, listener)
  })

  return function () {
    if (!eventsToReply) {
      return
    }

    // remove all buffering listeners
    listeners.forEach(function (listener, i) {
      emitter.removeListener(eventsToBuffer[i], listener)
    })

    // reply
    eventsToReply.forEach(function (args) {
      events.EventEmitter.prototype.emit.apply(emitter, args)
    })

    // free-up
    listeners = eventsToReply = null
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.file" id="apidoc.module.karma.file">module karma.file</a></h1>


    <h2>
        <a href="#apidoc.element.karma.file.file" id="apidoc.element.karma.file.file">
        function <span class="apidocSignatureSpan">karma.</span>file
        <span class="apidocSignatureSpan">(path, mtime, doNotCache)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function (path, mtime, doNotCache) {
  // used for serving (processed path, eg some/file.coffee -&gt; some/file.coffee.js)
  this.path = path

  // original absolute path, id of the file
  this.originalPath = path

  // where the content is stored (processed)
  this.contentPath = path

  this.mtime = mtime
  this.isUrl = false

  this.doNotCache = _.isUndefined(doNotCache) ? false : doNotCache
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.file.prototype" id="apidoc.module.karma.file.prototype">module karma.file.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.karma.file.prototype.toString" id="apidoc.element.karma.file.prototype.toString">
        function <span class="apidocSignatureSpan">karma.file.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.path
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return "'" + obj + "'"
case 'undefined':
  return 'undefined'
case 'function':
  try {
    // function abc(a, b, c) { /* code goes here */ }
    //   -&gt; function abc(a, b, c) { ... }
    return obj.<span class="apidocCodeKeywordSpan">toString</span>().replace(/\{[\s\S]*\}/, '{ ... }')
  } catch (err) {
    if (err instanceof TypeError) {
      // Proxy(function abc(...) { ... })
      return 'Proxy(function ' + (obj.name || '') + '(...) { ... })'
    } else {
      throw err
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.file_list" id="apidoc.module.karma.file_list">module karma.file_list</a></h1>


    <h2>
        <a href="#apidoc.element.karma.file_list.file_list" id="apidoc.element.karma.file_list.file_list">
        function <span class="apidocSignatureSpan">karma.</span>file_list
        <span class="apidocSignatureSpan">(patterns, excludes, emitter, preprocess, batchInterval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file_list = function (patterns, excludes, emitter, preprocess, batchInterval) {
  // Store options
  this._patterns = patterns
  this._excludes = excludes
  this._emitter = emitter
  this._preprocess = Promise.promisify(preprocess)
  this._batchInterval = batchInterval

  // The actual list of files
  this.buckets = new Map()

  // Internal tracker if we are refreshing.
  // When a refresh is triggered this gets set
  // to the promise that `this._refresh` returns.
  // So we know we are refreshing when this promise
  // is still pending, and we are done when it's either
  // resolved or rejected.
  this._refreshing = Promise.resolve()

  var self = this

  // Emit the `file_list_modified` event.
  // This function is throttled to the value of `batchInterval`
  // to avoid spamming the listener.
  function emit () {
    self._emitter.emit('file_list_modified', self.files)
  }
  var throttledEmit = _.throttle(emit, self._batchInterval, {leading: false})
  self._emitModified = function (immediate) {
    immediate ? emit() : throttledEmit()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.file_list.prototype" id="apidoc.module.karma.file_list.prototype">module karma.file_list.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.karma.file_list.prototype._exists" id="apidoc.element.karma.file_list.prototype._exists">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_exists
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_exists = function (path) {
  var self = this

  var patterns = this._patterns.filter(function (pattern) {
    return mm(path, pattern.pattern)
  })

  return !!_.find(patterns, function (pattern) {
    return self._findFile(path, pattern)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var pattern = this._isIncluded(path)

if (!pattern) {
  log.debug('Add file "%s" ignored. Does not match any pattern.', path)
  return Promise.resolve(this.files)
}

if (this.<span class="apidocCodeKeywordSpan">_exists</span>(path)) {
  log.debug('Add file "%s" ignored. Already in the list.', path)
  return Promise.resolve(this.files)
}

var file = new File(path)
this.buckets.get(pattern.pattern).add(file)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype._findFile" id="apidoc.element.karma.file_list.prototype._findFile">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_findFile
        <span class="apidocSignatureSpan">(path, pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findFile = function (path, pattern) {
  if (!path || !pattern) return
  if (!this.buckets.has(pattern.pattern)) return

  return _.find(from(this.buckets.get(pattern.pattern)), function (file) {
    return file.originalPath === path
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var self = this

  var patterns = this._patterns.filter(function (pattern) {
    return mm(path, pattern.pattern)
  })

  return !!_.find(patterns, function (pattern) {
    return self.<span class="apidocCodeKeywordSpan">_findFile</span>(path, pattern)
  })
}

// Check if we are currently refreshing
List.prototype._isRefreshing = function () {
  return this._refreshing.isPending()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype._isExcluded" id="apidoc.element.karma.file_list.prototype._isExcluded">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_isExcluded
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isExcluded = function (path) {
  return _.find(this._excludes, function (pattern) {
    return mm(path, pattern)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (_.isEmpty(files)) {
log.warn('Pattern "%s" does not match any file.', pattern)
return
    }

    return Promise.map(files, function (path) {
if (self.<span class="apidocCodeKeywordSpan">_isExcluded</span>(path)) {
  log.debug('Excluded file "%s"', path)
  return Promise.resolve()
}

if (matchedFiles.has(path)) {
  return Promise.resolve()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype._isIncluded" id="apidoc.element.karma.file_list.prototype._isIncluded">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_isIncluded
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isIncluded = function (path) {
  return _.find(this._patterns, function (pattern) {
    return mm(path, pattern.pattern)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var excluded = this._isExcluded(path)
if (excluded) {
  log.debug('Add file "%s" ignored. Excluded by "%s".', path, excluded)

  return Promise.resolve(this.files)
}

var pattern = this.<span class="apidocCodeKeywordSpan">_isIncluded</span>(path)

if (!pattern) {
  log.debug('Add file "%s" ignored. Does not match any pattern.', path)
  return Promise.resolve(this.files)
}

if (this._exists(path)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype._isRefreshing" id="apidoc.element.karma.file_list.prototype._isRefreshing">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_isRefreshing
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isRefreshing = function () {
  return this._refreshing.isPending()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype._refresh" id="apidoc.element.karma.file_list.prototype._refresh">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>_refresh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_refresh = function () {
  var self = this
  var buckets = this.buckets
  var matchedFiles = new Set()

  var promise = Promise.map(this._patterns, function (patternObject) {
    var pattern = patternObject.pattern

    if (helper.isUrlAbsolute(pattern)) {
      buckets.set(pattern, new Set([new Url(pattern)]))
      return Promise.resolve()
    }

    var mg = new Glob(pathLib.normalize(pattern), GLOB_OPTS)
    var files = mg.found
    buckets.set(pattern, new Set())

    if (_.isEmpty(files)) {
      log.warn('Pattern "%s" does not match any file.', pattern)
      return
    }

    return Promise.map(files, function (path) {
      if (self._isExcluded(path)) {
        log.debug('Excluded file "%s"', path)
        return Promise.resolve()
      }

      if (matchedFiles.has(path)) {
        return Promise.resolve()
      }

      matchedFiles.add(path)

      var mtime = mg.statCache[path].mtime
      var doNotCache = patternObject.nocache
      var file = new File(path, mtime, doNotCache)

      if (file.doNotCache) {
        log.debug('Not preprocessing "%s" due to nocache')
        return Promise.resolve(file)
      }

      return self._preprocess(file).then(function () {
        return file
      })
    })
    .then(function (files) {
      files = _.compact(files)

      if (_.isEmpty(files)) {
        log.warn('All files matched by "%s" were excluded or matched by prior matchers.', pattern)
      } else {
        buckets.set(pattern, new Set(files))
      }
    })
  })
  .then(function () {
    if (self._refreshing !== promise) {
      return self._refreshing
    }
    self.buckets = buckets
    self._emitModified(true)
    return self.files
  })

  return promise
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})

// Reglob all patterns to update the list.
//
// Returns a promise that is resolved when the refresh
// is completed.
List.prototype.refresh = function () {
  this._refreshing = this.<span class="apidocCodeKeywordSpan">_refresh</span>()
  return this._refreshing
}

// Set new patterns and excludes and update
// the list accordingly
//
// patterns - Array, the new patterns.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype.addFile" id="apidoc.element.karma.file_list.prototype.addFile">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>addFile
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFile = function (path) {
  var self = this

  // Ensure we are not adding a file that should be excluded
  var excluded = this._isExcluded(path)
  if (excluded) {
    log.debug('Add file "%s" ignored. Excluded by "%s".', path, excluded)

    return Promise.resolve(this.files)
  }

  var pattern = this._isIncluded(path)

  if (!pattern) {
    log.debug('Add file "%s" ignored. Does not match any pattern.', path)
    return Promise.resolve(this.files)
  }

  if (this._exists(path)) {
    log.debug('Add file "%s" ignored. Already in the list.', path)
    return Promise.resolve(this.files)
  }

  var file = new File(path)
  this.buckets.get(pattern.pattern).add(file)

  return Promise.all([
    fs.statAsync(path),
    this._refreshing
  ]).spread(function (stat) {
    file.mtime = stat.mtime
    return self._preprocess(file)
  })
  .then(function () {
    log.info('Added file "%s".', path)
    self._emitModified()
    return self.files
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    fileList.changeFile(path.resolve(config.basePath, filepath))
    fullRefresh = false
  })
}

if (helper.isArray(data.addedFiles)) {
  data.addedFiles.forEach(function (filepath) {
    fileList.<span class="apidocCodeKeywordSpan">addFile</span>(path.resolve(config.basePath, filepath))
    fullRefresh = false
  })
}

if (helper.isArray(data.removedFiles)) {
  data.removedFiles.forEach(function (filepath) {
    fileList.removeFile(path.resolve(config.basePath, filepath))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype.changeFile" id="apidoc.element.karma.file_list.prototype.changeFile">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>changeFile
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">changeFile = function (path) {
  var self = this

  var pattern = this._isIncluded(path)
  var file = this._findFile(path, pattern)

  if (!pattern || !file) {
    log.debug('Changed file "%s" ignored. Does not match any file in the list.', path)
    return Promise.resolve(this.files)
  }

  return Promise.all([
    fs.statAsync(path),
    this._refreshing
  ]).spread(function (stat) {
    if (stat.mtime &lt;= file.mtime) throw new Promise.CancellationError()

    file.mtime = stat.mtime
    return self._preprocess(file)
  })
  .then(function () {
    log.info('Changed file "%s".', path)
    self._emitModified()
    return self.files
  })
  .catch(Promise.CancellationError, function () {
    return self.files
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  config.client.args = data.args
}

var fullRefresh = true

if (helper.isArray(data.changedFiles)) {
  data.changedFiles.forEach(function (filepath) {
    fileList.<span class="apidocCodeKeywordSpan">changeFile</span>(path.resolve(config.basePath, filepath))
    fullRefresh = false
  })
}

if (helper.isArray(data.addedFiles)) {
  data.addedFiles.forEach(function (filepath) {
    fileList.addFile(path.resolve(config.basePath, filepath))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype.refresh" id="apidoc.element.karma.file_list.prototype.refresh">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>refresh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refresh = function () {
  this._refreshing = this._refresh()
  return this._refreshing
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// is completed.
List.prototype.reload = function (patterns, excludes) {
  this._patterns = patterns
  this._excludes = excludes

  // Wait until the current refresh is done and then do a
  // refresh to ensure a refresh actually happens
  return this.<span class="apidocCodeKeywordSpan">refresh</span>()
}

// Add a new file from the list.
// This is called by the watcher
//
// path - String, the path of the file to update.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype.reload" id="apidoc.element.karma.file_list.prototype.reload">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>reload
        <span class="apidocSignatureSpan">(patterns, excludes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reload = function (patterns, excludes) {
  this._patterns = patterns
  this._excludes = excludes

  // Wait until the current refresh is done and then do a
  // refresh to ensure a refresh actually happens
  return this.refresh()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.file_list.prototype.removeFile" id="apidoc.element.karma.file_list.prototype.removeFile">
        function <span class="apidocSignatureSpan">karma.file_list.prototype.</span>removeFile
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeFile = function (path) {
  var self = this

  return Promise.try(function () {
    var pattern = self._isIncluded(path)
    var file = self._findFile(path, pattern)

    if (!pattern || !file) {
      log.debug('Removed file "%s" ignored. Does not match any file in the list.', path)
      return self.files
    }

    self.buckets.get(pattern.pattern).delete(file)

    log.info('Removed file "%s".', path)
    self._emitModified()
    return self.files
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    fileList.addFile(path.resolve(config.basePath, filepath))
    fullRefresh = false
  })
}

if (helper.isArray(data.removedFiles)) {
  data.removedFiles.forEach(function (filepath) {
    fileList.<span class="apidocCodeKeywordSpan">removeFile</span>(path.resolve(config.basePath, filepath))
    fullRefresh = false
  })
}

if (fullRefresh &amp;&amp; data.refresh !== false) {
  log.debug('Refreshing all the files / patterns')
  fileList.refresh().then(function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.formatters" id="apidoc.module.karma.formatters">module karma.formatters</a></h1>


    <h2>
        <a href="#apidoc.element.karma.formatters.Coffee" id="apidoc.element.karma.formatters.Coffee">
        function <span class="apidocSignatureSpan">karma.formatters.</span>Coffee
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Coffee = function () {
  JavaScriptFormatter.call(this)

  this.TEMPLATE_FILE_PATH = COFFEE_TEMPLATE_PATH
  this.REQUIREJS_TEMPLATE_FILE = COFFEE_REQUIREJS_TEMPLATE_PATH
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.formatters.JavaScript" id="apidoc.element.karma.formatters.JavaScript">
        function <span class="apidocSignatureSpan">karma.formatters.</span>JavaScript
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JavaScript = function () {
  var quote = function (value) {
    return "'" + value + "'"
  }

  var quoteNonIncludedPattern = function (value) {
    return util.format('{pattern: %s, included: false}', quote(value))
  }

  var pad = function (str, pad) {
    return str.replace(/\n/g, '\n' + pad).replace(/\s+$/gm, '')
  }

  var formatQuottedList = function (list) {
    return list.map(quote).join(', ')
  }

  this.TEMPLATE_FILE_PATH = JS_TEMPLATE_PATH
  this.REQUIREJS_TEMPLATE_FILE = JS_REQUIREJS_TEMPLATE_PATH

  this.formatFiles = function (includedFiles, onlyServedFiles) {
    var files = includedFiles.map(quote)

    onlyServedFiles.forEach(function (onlyServedFile) {
      files.push(quoteNonIncludedPattern(onlyServedFile))
    })

    files = files.map(function (file) {
      return '\n      ' + file
    })

    return files.join(',')
  }

  this.formatPreprocessors = function (preprocessors) {
    var lines = []
    Object.keys(preprocessors).forEach(function (pattern) {
      lines.push('  ' + quote(pattern) + ': [' + formatQuottedList(preprocessors[pattern]) + ']')
    })

    return pad('{\n' + lines.join(',\n') + '\n}', '    ')
  }

  this.formatFrameworks = formatQuottedList

  this.formatBrowsers = formatQuottedList

  this.formatAnswers = function (answers) {
    return {
      DATE: new Date(),
      BASE_PATH: answers.basePath,
      FRAMEWORKS: this.formatFrameworks(answers.frameworks),
      FILES: this.formatFiles(answers.files, answers.onlyServedFiles),
      EXCLUDE: this.formatFiles(answers.exclude, []),
      AUTO_WATCH: answers.autoWatch ? 'true' : 'false',
      BROWSERS: this.formatBrowsers(answers.browsers),
      PREPROCESSORS: this.formatPreprocessors(answers.preprocessors)
    }
  }

  this.generateConfigFile = function (answers) {
    var template = fs.readFileSync(this.TEMPLATE_FILE_PATH).toString()
    var replacements = this.formatAnswers(answers)

    return template.replace(/%(.*)%/g, function (a, key) {
      return replacements[key]
    })
  }

  this.writeConfigFile = function (path, answers) {
    fs.writeFileSync(path, this.generateConfigFile(answers))
  }

  this.generateRequirejsConfigFile = function () {
    var template = fs.readFileSync(this.REQUIREJS_TEMPLATE_FILE).toString()
    return template
  }

  this.writeRequirejsConfigFile = function (path) {
    fs.writeFileSync(path, this.generateRequirejsConfigFile())
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.formatters.Live" id="apidoc.element.karma.formatters.Live">
        function <span class="apidocSignatureSpan">karma.formatters.</span>Live
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Live = function () {
  JavaScriptFormatter.call(this)

  this.TEMPLATE_FILE_PATH = LIVE_TEMPLATE_PATH
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.formatters.Type" id="apidoc.element.karma.formatters.Type">
        function <span class="apidocSignatureSpan">karma.formatters.</span>Type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Type = function () {
  JavaScriptFormatter.call(this)

  this.TEMPLATE_FILE_PATH = TYPE_TEMPLATE_PATH
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.formatters.createForPath" id="apidoc.element.karma.formatters.createForPath">
        function <span class="apidocSignatureSpan">karma.formatters.</span>createForPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createForPath = function (path) {
  if (isCoffeeFile(path)) {
    return new CoffeeFormatter()
  }

  if (isLiveFile(path)) {
    return new LiveFormatter()
  }

  if (isTypeFile(path)) {
    return new TypeFormatter()
  }

  return new JavaScriptFormatter()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sm.on('next_question', printLogQueue)

  sm.process(questions, function (answers) {
var cwd = process.cwd()
var configFile = config.configFile || 'karma.conf.js'
var isCoffee = path.extname(configFile) === '.coffee'
var testMainFile = isCoffee ? 'test-main.coffee' : 'test-main.js'
var formatter = formatters.<span class="apidocCodeKeywordSpan">createForPath</span>(configFile)
var processedAnswers = processAnswers(answers, getBasePath(configFile, cwd), testMainFile)
var configFilePath = path.resolve(cwd, configFile)
var testMainFilePath = path.resolve(cwd, testMainFile)

if (isCoffee) {
  installPackage('coffee-script')
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.helper" id="apidoc.module.karma.helper">module karma.helper</a></h1>


    <h2>
        <a href="#apidoc.element.karma.helper.arrayRemove" id="apidoc.element.karma.helper.arrayRemove">
        function <span class="apidocSignatureSpan">karma.helper.</span>arrayRemove
        <span class="apidocSignatureSpan">(collection, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayRemove = function (collection, item) {
  var idx = collection.indexOf(item)

  if (idx !== -1) {
    collection.splice(idx, 1)
    return true
  }

  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    reporters.forEach(function (reporter) {
      reporter.adapters.push(adapter)
    })
  }

  this.removeAdapter = function (adapter) {
    reporters.forEach(function (reporter) {
      helper.<span class="apidocCodeKeywordSpan">arrayRemove</span>(reporter.adapters, adapter)
    })
  }
}

// PUBLISH
module.exports = MultiReporter
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.browserFullNameToShort" id="apidoc.element.karma.helper.browserFullNameToShort">
        function <span class="apidocSignatureSpan">karma.helper.</span>browserFullNameToShort
        <span class="apidocSignatureSpan">(fullName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">browserFullNameToShort = function (fullName) {
  var agent = useragent.parse(fullName)
  var isKnown = agent.family !== 'Other' &amp;&amp; agent.os.family !== 'Other'
  return isKnown ? agent.toAgent() + ' (' + agent.os + ')' : fullName
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// The browser got permanently disconnected (being removed from the collection and destroyed).
var DISCONNECTED = 5

var Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,
/* config.browserDisconnectTimeout */ disconnectDelay,
/* config.browserNoActivityTimeout */ noActivityTimeout) {
var name = helper.<span class="apidocCodeKeywordSpan">browserFullNameToShort</span>(fullName)
var log = logger.create(name)
var activeSockets = [socket]
var activeSocketsIds = function () {
  return activeSockets.map(function (s) {
    return s.id
  }).join(', ')
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.camelToSnake" id="apidoc.element.karma.helper.camelToSnake">
        function <span class="apidocSignatureSpan">karma.helper.</span>camelToSnake
        <span class="apidocSignatureSpan">(camelCase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">camelToSnake = function (camelCase) {
  return camelCase.replace(/[A-Z]/g, function (match, pos) {
    return (pos &gt; 0 ? '_' : '') + match.toLowerCase()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var helper = require('./helper')

var bindAllEvents = function (object, context) {
context = context || this

var bindMethod = function (method) {
  context.on(helper.<span class="apidocCodeKeywordSpan">camelToSnake</span>(method.substr(2)), function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.push(context)
    object[method].apply(object, args)
  })
}

for (var method in object) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.dashToCamel" id="apidoc.element.karma.helper.dashToCamel">
        function <span class="apidocSignatureSpan">karma.helper.</span>dashToCamel
        <span class="apidocSignatureSpan">(dash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dashToCamel = function (dash) {
  var words = dash.split('-')
  return words.shift() + words.map(exports.ucFirst).join('')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Object.getOwnPropertyNames(argv).forEach(function (name) {
  var argumentValue = argv[name]
  if (name !== '_' &amp;&amp; name !== '$0') {
    if (Array.isArray(argumentValue)) {
      // If the same argument is defined multiple times, override.
      argumentValue = argumentValue.pop()
    }
    options[helper.<span class="apidocCodeKeywordSpan">dashToCamel</span>(name)] = argumentValue
  }
})

if (helper.isString(options.autoWatch)) {
  options.autoWatch = options.autoWatch === 'true'
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.defer" id="apidoc.element.karma.helper.defer">
        function <span class="apidocSignatureSpan">karma.helper.</span>defer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defer = function () {
  var resolve
  var reject
  var promise = new Promise(function () {
    resolve = arguments[0]
    reject = arguments[1]
  })

  return {
    resolve: resolve,
    reject: reject,
    promise: promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var EventEmitter = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
// TODO(vojta): allow passing args
// TODO(vojta): ignore/throw if listener call done() multiple times
var pending = this.listeners(name).length
var deferred = helper.<span class="apidocCodeKeywordSpan">defer</span>()
var done = function () {
  if (!--pending) {
    deferred.resolve()
  }
}

this.emit(name, done)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.formatTimeInterval" id="apidoc.element.karma.helper.formatTimeInterval">
        function <span class="apidocSignatureSpan">karma.helper.</span>formatTimeInterval
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatTimeInterval = function (time) {
  var mins = Math.floor(time / 60000)
  var secs = (time - mins * 60000) / 1000
  var str = secs + (secs === 1 ? ' sec' : ' secs')

  if (mins) {
    str = mins + (mins === 1 ? ' min ' : ' mins ') + str
  }

  return str
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.isArray" id="apidoc.element.karma.helper.isArray">
        function <span class="apidocSignatureSpan">karma.helper.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.exit(0)
}

// TODO(vojta): warn/throw when unknown argument (probably mispelled)
Object.getOwnPropertyNames(argv).forEach(function (name) {
  var argumentValue = argv[name]
  if (name !== '_' &amp;&amp; name !== '$0') {
    if (Array.<span class="apidocCodeKeywordSpan">isArray</span>(argumentValue)) {
      // If the same argument is defined multiple times, override.
      argumentValue = argumentValue.pop()
    }
    options[helper.dashToCamel(name)] = argumentValue
  }
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.isDefined" id="apidoc.element.karma.helper.isDefined">
        function <span class="apidocSignatureSpan">karma.helper.</span>isDefined
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDefined = function (value) {
  return !_.isUndefined(value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  this.onInfo = function (info) {
if (this.isReady()) {
  return
}

// TODO(vojta): remove
if (helper.<span class="apidocCodeKeywordSpan">isDefined</span>(info.dump)) {
  emitter.emit('browser_log', this, info.dump, 'dump')
}

if (helper.isDefined(info.log)) {
  emitter.emit('browser_log', this, info.log, info.type)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.isFunction" id="apidoc.element.karma.helper.isFunction">
        function <span class="apidocSignatureSpan">karma.helper.</span>isFunction
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) &amp;&amp; objToString.call(value) == funcTag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  try {
    var required = require(options.formatError)
  } catch (err) {
    console.error('Could not require formatError: ' + options.formatError, err)
  }
  // support exports.formatError and module.exports = function
  options.formatError = required.formatError || required
  if (!helper.<span class="apidocCodeKeywordSpan">isFunction</span>(options.formatError)) {
    console.error('Format error must be a function, got: ' + typeof options.formatError)
    process.exit(1)
  }
}

if (helper.isString(options.logLevel)) {
  var logConstant = constant['LOG_' + options.logLevel.toUpperCase()]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.isNumber" id="apidoc.element.karma.helper.isNumber">
        function <span class="apidocSignatureSpan">karma.helper.</span>isNumber
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumber(value) {
  return typeof value == 'number' || (isObjectLike(value) &amp;&amp; objToString.call(value) == numberTag);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new TypeError('Invalid configuration: browsers option must be an array')
}

if (config.formatError &amp;&amp; !helper.isFunction(config.formatError)) {
  throw new TypeError('Invalid configuration: formatError option must be a function.')
}

if (config.processKillTimeout &amp;&amp; !helper.<span class="apidocCodeKeywordSpan">isNumber</span>(config.processKillTimeout
)) {
  throw new TypeError('Invalid configuration: processKillTimeout option must be a number.')
}

var defaultClient = config.defaultClient || {}
Object.keys(defaultClient).forEach(function (key) {
  var option = config.client[key]
  config.client[key] = helper.isDefined(option) ? option : defaultClient[key]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.isObject" id="apidoc.element.karma.helper.isObject">
        function <span class="apidocSignatureSpan">karma.helper.</span>isObject
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value &amp;&amp; (type == 'object' || type == 'function');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var createPatternObject = function (pattern) {
if (pattern &amp;&amp; helper.isString(pattern)) {
  return helper.isUrlAbsolute(pattern) ? new UrlPattern(pattern) : new Pattern(pattern)
}

if (helper.<span class="apidocCodeKeywordSpan">isObject</span>(pattern)) {
  if (pattern.pattern &amp;&amp; helper.isString(pattern.pattern)) {
    return helper.isUrlAbsolute(pattern.pattern)
      ? new UrlPattern(pattern.pattern)
      : new Pattern(
        pattern.pattern,
        pattern.served,
        pattern.included,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.isString" id="apidoc.element.karma.helper.isString">
        function <span class="apidocSignatureSpan">karma.helper.</span>isString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(value) {
  return typeof value == 'string' || (isObjectLike(value) &amp;&amp; objToString.call(value) == stringTag);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // If the same argument is defined multiple times, override.
      argumentValue = argumentValue.pop()
    }
    options[helper.dashToCamel(name)] = argumentValue
  }
})

if (helper.<span class="apidocCodeKeywordSpan">isString</span>(options.autoWatch)) {
  options.autoWatch = options.autoWatch === 'true'
}

if (helper.isString(options.colors)) {
  options.colors = options.colors === 'true'
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.isUrlAbsolute" id="apidoc.element.karma.helper.isUrlAbsolute">
        function <span class="apidocSignatureSpan">karma.helper.</span>isUrlAbsolute
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUrlAbsolute = function (url) {
  return ABS_URL.test(url)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var UrlPattern = function (url) {
Pattern.call(this, url, false, true, false, false)
}

var createPatternObject = function (pattern) {
if (pattern &amp;&amp; helper.isString(pattern)) {
  return helper.<span class="apidocCodeKeywordSpan">isUrlAbsolute</span>(pattern) ? new UrlPattern(pattern) : new Pattern(pattern
)
}

if (helper.isObject(pattern)) {
  if (pattern.pattern &amp;&amp; helper.isString(pattern.pattern)) {
    return helper.isUrlAbsolute(pattern.pattern)
      ? new UrlPattern(pattern.pattern)
      : new Pattern(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.merge" id="apidoc.element.karma.helper.merge">
        function <span class="apidocSignatureSpan">karma.helper.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  var args = Array.prototype.slice.call(arguments, 0)
  args.unshift({})
  return _.merge.apply({}, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.LOG_DISABLE = constant.LOG_DISABLE
this.LOG_ERROR = constant.LOG_ERROR
this.LOG_WARN = constant.LOG_WARN
this.LOG_INFO = constant.LOG_INFO
this.LOG_DEBUG = constant.LOG_DEBUG

this.set = function (newConfig) {
  _.<span class="apidocCodeKeywordSpan">merge</span>(config, newConfig, function (obj, src) {
    // Overwrite arrays to keep consistent with #283
    if (_.isArray(src)) {
      return src
    }
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.mkdirIfNotExists" id="apidoc.element.karma.helper.mkdirIfNotExists">
        function <span class="apidocSignatureSpan">karma.helper.</span>mkdirIfNotExists
        <span class="apidocSignatureSpan">(directory, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdir(directory, done) {
  // TODO(vojta): handle if it's a file
<span class="apidocCodeCommentSpan">  /* eslint-disable handle-callback-err */
</span>  fs.stat(directory, function (err, stat) {
    if (stat &amp;&amp; stat.isDirectory()) {
      done()
    } else {
      mkdir(path.dirname(directory), function () {
        fs.mkdir(directory, done)
      })
    }
  })
  /* eslint-enable handle-callback-err */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.mmComparePatternWeights" id="apidoc.element.karma.helper.mmComparePatternWeights">
        function <span class="apidocSignatureSpan">karma.helper.</span>mmComparePatternWeights
        <span class="apidocSignatureSpan">(weight1, weight2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mmComparePatternWeights = function (weight1, weight2) {
  var n1, n2, diff
  n1 = weight1[0]
  n2 = weight2[0]
  diff = n1 - n2
  if (diff !== 0) return diff / Math.abs(diff)
  return weight1.length &gt; 1 ? exports.mmComparePatternWeights(weight1.slice(1), weight2.slice(1)) : 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.included = helper.isDefined(included) ? included : true
  this.watched = helper.isDefined(watched) ? watched : true
  this.nocache = helper.isDefined(nocache) ? nocache : false
  this.weight = helper.mmPatternWeight(pattern)
}

Pattern.prototype.compare = function (other) {
  return helper.<span class="apidocCodeKeywordSpan">mmComparePatternWeights</span>(this.weight, other.weight)
}

var UrlPattern = function (url) {
  Pattern.call(this, url, false, true, false, false)
}

var createPatternObject = function (pattern) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.mmPatternWeight" id="apidoc.element.karma.helper.mmPatternWeight">
        function <span class="apidocSignatureSpan">karma.helper.</span>mmPatternWeight
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mmPatternWeight = function (pattern) {
  var m = new mm.Minimatch(pattern)
  if (!m.globParts) return [0, 0, 0, 0, 0, 0]
  var result = m.globParts.reduce(function (prev, p) {
    var r = p.reduce(function (prev, p) {
      return gsParser(p, prev)
    }, {glob_star: 0, ext_glob: 0, word: 0, star: 0, optional: 0, range: 0})
    if (prev === undefined) return r
    return compareWeightObject(r, prev) &gt; 0 ? r : prev
  }, undefined)
  result.glob_sets = m.set.length
  return [result.glob_sets, result.glob_star, result.star, result.ext_glob, result.range, result.optional]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var Pattern = function (pattern, served, included, watched, nocache) {
  this.pattern = pattern
  this.served = helper.isDefined(served) ? served : true
  this.included = helper.isDefined(included) ? included : true
  this.watched = helper.isDefined(watched) ? watched : true
  this.nocache = helper.isDefined(nocache) ? nocache : false
  this.weight = helper.<span class="apidocCodeKeywordSpan">mmPatternWeight</span>(pattern)
}

Pattern.prototype.compare = function (other) {
  return helper.mmComparePatternWeights(this.weight, other.weight)
}

var UrlPattern = function (url) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.normalizeWinPath" id="apidoc.element.karma.helper.normalizeWinPath">
        function <span class="apidocSignatureSpan">karma.helper.</span>normalizeWinPath
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function identity(value) {
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
config.files = config.files.map(createPatternObject).map(createPatternMapper(basePathResolve))
config.exclude = config.exclude.map(basePathResolve)
config.customContextFile = config.customContextFile &amp;&amp; basePathResolve(config.customContextFile)
config.customDebugFile = config.customDebugFile &amp;&amp; basePathResolve(config.customDebugFile)
config.customClientContextFile = config.customClientContextFile &amp;&amp; basePathResolve(config.customClientContextFile)

// normalize paths on windows
config.basePath = helper.<span class="apidocCodeKeywordSpan">normalizeWinPath</span>(config.basePath)
config.files = config.files.map(createPatternMapper(helper.normalizeWinPath))
config.exclude = config.exclude.map(helper.normalizeWinPath)
config.customContextFile = helper.normalizeWinPath(config.customContextFile)
config.customDebugFile = helper.normalizeWinPath(config.customDebugFile)
config.customClientContextFile = helper.normalizeWinPath(config.customClientContextFile)

// normalize urlRoot
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.helper.ucFirst" id="apidoc.element.karma.helper.ucFirst">
        function <span class="apidocSignatureSpan">karma.helper.</span>ucFirst
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ucFirst = function (word) {
  return word.charAt(0).toUpperCase() + word.substr(1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // define custom launchers/preprocessors/reporters - create an inlined plugin
  var module = Object.create(null)
  var hasSomeInlinedPlugin = false
  var types = ['launcher', 'preprocessor', 'reporter']

  types.forEach(function (type) {
    var definitions = config['custom' + helper.<span class="apidocCodeKeywordSpan">ucFirst</span>(type) + 's'
;] || {}

    Object.keys(definitions).forEach(function (name) {
var definition = definitions[name]

if (!helper.isObject(definition)) {
  return log.warn('Can not define %s %s. Definition has to be an object.', type, name)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.init" id="apidoc.module.karma.init">module karma.init</a></h1>


    <h2>
        <a href="#apidoc.element.karma.init.init" id="apidoc.element.karma.init.init">
        function <span class="apidocSignatureSpan">karma.</span>init
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (config) {
  logger.setupFromConfig(config)

  var colorScheme = COLOR_SCHEME.ON

  if (helper.isDefined(config.colors)) {
    colorScheme = config.colors ? COLOR_SCHEME.ON : COLOR_SCHEME.OFF
  }
  // need to be registered before creating readlineInterface
  process.stdin.on('keypress', function (s, key) {
    sm.onKeypress(key)
  })

  var rli = readline.createInterface(process.stdin, process.stdout)
  var sm = new StateMachine(rli, colorScheme)

  rli.on('line', sm.onLine.bind(sm))

  // clean colors
  rli.on('SIGINT', function () {
    sm.kill()
    process.exit(0)
  })

  sm.on('next_question', printLogQueue)

  sm.process(questions, function (answers) {
    var cwd = process.cwd()
    var configFile = config.configFile || 'karma.conf.js'
    var isCoffee = path.extname(configFile) === '.coffee'
    var testMainFile = isCoffee ? 'test-main.coffee' : 'test-main.js'
    var formatter = formatters.createForPath(configFile)
    var processedAnswers = processAnswers(answers, getBasePath(configFile, cwd), testMainFile)
    var configFilePath = path.resolve(cwd, configFile)
    var testMainFilePath = path.resolve(cwd, testMainFile)

    if (isCoffee) {
      installPackage('coffee-script')
    }

    if (processedAnswers.generateTestMain) {
      formatter.writeRequirejsConfigFile(testMainFilePath)
      console.log(colorScheme.success(
        'RequireJS bootstrap file generated at "' + testMainFilePath + '".\n'
      ))
    }

    formatter.writeConfigFile(configFilePath, processedAnswers)
    console.log(colorScheme.success('Config file generated at "' + configFilePath + '".\n'))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'run':
      require('./runner').run(config)
      break
    case 'stop':
      require('./stopper').stop(config)
      break
    case 'init':
      require('./init').<span class="apidocCodeKeywordSpan">init</span>(config)
      break
    case 'completion':
      require('./completion').completion(config)
      break
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.karma" id="apidoc.module.karma.karma">module karma.karma</a></h1>


    <h2>
        <a href="#apidoc.element.karma.karma.karma" id="apidoc.element.karma.karma.karma">
        function <span class="apidocSignatureSpan">karma.</span>karma
        <span class="apidocSignatureSpan">(callParentKarmaMethod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">karma = function (callParentKarmaMethod) {
  // Define local variables
  var hasError = false
  var self = this

  // Define our loggers
  // DEV: These are intentionally repeated in client and context
  this.log = function (type, args) {
    var values = []

    for (var i = 0; i &lt; args.length; i++) {
      values.push(this.stringify(args[i], 3))
    }

    this.info({log: values.join(', '), type: type})
  }

  this.stringify = stringify

  // Define our proxy error handler
  // DEV: We require one in our context to track `hasError`
  this.error = function () {
    hasError = true
    callParentKarmaMethod('error', [].slice.call(arguments))
    return false
  }

  // Define our start handler
  var UNIMPLEMENTED_START = function () {
    this.error('You need to include some adapter that implements __karma__.start method!')
  }
  // all files loaded, let's start the execution
  this.loaded = function () {
    // has error -&gt; cancel
    if (!hasError) {
      this.start(this.config)
    }

    // remove reference to child iframe
    this.start = UNIMPLEMENTED_START
  }
  // supposed to be overriden by the context
  // TODO(vojta): support multiple callbacks (queue)
  this.start = UNIMPLEMENTED_START

  // Define proxy methods
  // DEV: This is a closured `for` loop (same as a `forEach`) for IE support
  var proxyMethods = ['complete', 'info', 'result']
  for (var i = 0; i &lt; proxyMethods.length; i++) {
    (function bindProxyMethod (methodName) {
      self[methodName] = function boundProxyMethod () {
        callParentKarmaMethod(methodName, [].slice.call(arguments))
      }
    }(proxyMethods[i]))
  }

  // Define bindings for context window
  this.setupContext = function (contextWindow) {
    // If we clear the context after every run and we already had an error
    //   then stop now. Otherwise, carry on.
    if (self.config.clearContext &amp;&amp; hasError) {
      return
    }

    // Perform window level bindings
    // DEV: We return `self.error` since we want to `return false` to ignore errors
    contextWindow.onerror = function () {
      return self.error.apply(self, arguments)
    }
    // DEV: We must defined a function since we don't want to pass the event object
    contextWindow.onbeforeunload = function (e, b) {
      callParentKarmaMethod('onbeforeunload', [])
    }

    contextWindow.dump = function () {
      self.log('dump', arguments)
    }

    var _confirm = contextWindow.confirm
    var _prompt = contextWindow.prompt

    contextWindow.alert = function (msg) {
      self.log('alert', [msg])
    }

    contextWindow.confirm = function (msg) {
      self.log('confirm', [msg])
      return _confirm(msg)
    }

    contextWindow.prompt = function (msg, defaultVal) {
      self.log('prompt', [msg, defaultVal])
      return _prompt(msg, defaultVal)
    }

    // If we want to overload our console, then do it
    var getConsole = function (currentWindow) {
      return currentWindow.console || {
        log: function () {},
        info: function () {},
        warn: function () {},
        error: function () {},
        debug: function () {}
      }
    }
    if (self.config.captureConsole) {
      // patch the console
      var localConsole = contextWindow.console = getConsole(contextWindow)
      var logMethods = ['log', 'info', 'warn', 'error', 'debug']
      var patchConsoleMethod = function (method) {
        var orig = localConsole[method]
        if (!orig) {
          return
        }
        localConsole[method] = function () {
          self.log(method, arguments)
          return Function.prototype.apply.call(orig, localConsole, arguments)
        }
      }
      for (var i = 0; i &lt; logMethods.length; i++) {
        patchConsoleMethod(logMethods[i])
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.karma.getDirectCallParentKarmaMethod" id="apidoc.element.karma.karma.getDirectCallParentKarmaMethod">
        function <span class="apidocSignatureSpan">karma.karma.</span>getDirectCallParentKarmaMethod
        <span class="apidocSignatureSpan">(parentWindow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDirectCallParentKarmaMethod = function (parentWindow) {
  return function directCallParentKarmaMethod (method, args) {
    // If the method doesn't exist, then error out
    if (!parentWindow.karma[method]) {
      parentWindow.karma.error('Expected Karma method "' + method + '" to exist but it doesn\'t')
      return
    }

    // Otherwise, run our method
    parentWindow.karma[method].apply(parentWindow.karma, args)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Load in our dependencies
var ContextKarma = require('./karma')

// Resolve our parent window
var parentWindow = window.opener || window.parent

// Define a remote call method for Karma
var callParentKarmaMethod = ContextKarma.<span class="apidocCodeKeywordSpan">getDirectCallParentKarmaMethod</span>(parentWindow)

// If we don't have access to the window, then use `postMessage`
// DEV: In Electron, we don't have access to the parent window due to it being in a separate process
// DEV: We avoid using this in Internet Explorer as they only support strings
//   http://caniuse.com/#search=postmessage
var haveParentAccess = false
try { haveParentAccess = !!parentWindow.window } catch (err) { /* Ignore errors (likely permisison errors) */ }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.karma.getPostMessageCallParentKarmaMethod" id="apidoc.element.karma.karma.getPostMessageCallParentKarmaMethod">
        function <span class="apidocSignatureSpan">karma.karma.</span>getPostMessageCallParentKarmaMethod
        <span class="apidocSignatureSpan">(parentWindow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPostMessageCallParentKarmaMethod = function (parentWindow) {
  return function postMessageCallParentKarmaMethod (method, args) {
    parentWindow.postMessage({__karmaMethod: method, __karmaArguments: args}, window.location.origin)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we don't have access to the window, then use `postMessage`
// DEV: In Electron, we don't have access to the parent window due to it being in a separate process
// DEV: We avoid using this in Internet Explorer as they only support strings
//   http://caniuse.com/#search=postmessage
var haveParentAccess = false
try { haveParentAccess = !!parentWindow.window } catch (err) { /* Ignore errors (likely permisison errors) */ }
if (!haveParentAccess) {
  callParentKarmaMethod = ContextKarma.<span class="apidocCodeKeywordSpan">getPostMessageCallParentKarmaMethod</span>(parentWindow
)
}

// Define a window-scoped Karma
window.__karma__ = new ContextKarma(callParentKarmaMethod)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.launcher" id="apidoc.module.karma.launcher">module karma.launcher</a></h1>


    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher" id="apidoc.element.karma.launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &lt; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + '//' + hostname + ':' + port + urlRoot

      var locals = {
        id: ['value', Launcher.generateId()],
        name: ['value', name],
        processKillTimeout: ['value', processKillTimeout],
        baseLauncherDecorator: ['factory', baseDecorator],
        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],
        retryLauncherDecorator: ['factory', retryDecorator],
        processLauncherDecorator: ['factory', processDecorator],
        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf('/') !== -1) {
        name = 'Script'
      }

      try {
        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)
      } catch (e) {
        if (e.message.indexOf('No provider for "launcher:' + name + '"') !== -1) {
          log.error('Cannot load browser "%s": it is not registered! ' +
            'Perhaps you are missing some plugin?', name)
        } else {
          log.error('Cannot load browser "%s"!\n  ' + e.stack, name)
        }

        emitter.emit('load_error', 'launcher', name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on('browser_process_failure', function () {
          done(browser.error)
        })

        browser.on('done', function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      'Launching browser%s %s with %s',
      names.length &gt; 1 ? 's' : '',
      names.join(', '),
      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on('end', function (err) {
      log.debug('Finished all browsers')

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    'config.browsers',
    'config.concurrency',
    'config.processKillTimeout'
  ]

  this.launchSingle.$inject = [
    'config.protocol',
    'config.hostname',
    'config.port',
    'config.urlRoot',
    'config.upstreamProxy',
    'config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.launcher.Launcher" id="apidoc.module.karma.launcher.Launcher">module karma.launcher.Launcher</a></h1>


    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher.Launcher" id="apidoc.element.karma.launcher.Launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &lt; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + '//' + hostname + ':' + port + urlRoot

      var locals = {
        id: ['value', Launcher.generateId()],
        name: ['value', name],
        processKillTimeout: ['value', processKillTimeout],
        baseLauncherDecorator: ['factory', baseDecorator],
        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],
        retryLauncherDecorator: ['factory', retryDecorator],
        processLauncherDecorator: ['factory', processDecorator],
        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf('/') !== -1) {
        name = 'Script'
      }

      try {
        var browser = injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)
      } catch (e) {
        if (e.message.indexOf('No provider for "launcher:' + name + '"') !== -1) {
          log.error('Cannot load browser "%s": it is not registered! ' +
            'Perhaps you are missing some plugin?', name)
        } else {
          log.error('Cannot load browser "%s"!\n  ' + e.stack, name)
        }

        emitter.emit('load_error', 'launcher', name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info('Starting browser %s', helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on('browser_process_failure', function () {
          done(browser.error)
        })

        browser.on('done', function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      'Launching browser%s %s with %s',
      names.length &gt; 1 ? 's' : '',
      names.join(', '),
      concurrency === Infinity ? 'unlimited concurrency' : 'concurrency ' + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on('end', function (err) {
      log.debug('Finished all browsers')

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    'config.browsers',
    'config.concurrency',
    'config.processKillTimeout'
  ]

  this.launchSingle.$inject = [
    'config.protocol',
    'config.hostname',
    'config.port',
    'config.urlRoot',
    'config.upstreamProxy',
    'config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher.generateId" id="apidoc.element.karma.launcher.Launcher.generateId">
        function <span class="apidocSignatureSpan">karma.launcher.Launcher.</span>generateId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateId = function () {
  return '' + Math.floor(Math.random() * 100000000)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.logger" id="apidoc.module.karma.logger">module karma.logger</a></h1>


    <h2>
        <a href="#apidoc.element.karma.logger.create" id="apidoc.element.karma.logger.create">
        function <span class="apidocSignatureSpan">karma.logger.</span>create
        <span class="apidocSignatureSpan">(name, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (name, level) {
  var logger = log4js.getLogger(name || 'karma')
  if (helper.isDefined(level)) {
    logger.setLevel(level)
  }
  return logger
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The browser got permanently disconnected (being removed from the collection and destroyed).
var DISCONNECTED = 5

var Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,
/* config.browserDisconnectTimeout */ disconnectDelay,
/* config.browserNoActivityTimeout */ noActivityTimeout) {
var name = helper.browserFullNameToShort(fullName)
var log = logger.<span class="apidocCodeKeywordSpan">create</span>(name)
var activeSockets = [socket]
var activeSocketsIds = function () {
  return activeSockets.map(function (s) {
    return s.id
  }).join(', ')
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.logger.setup" id="apidoc.element.karma.logger.setup">
        function <span class="apidocSignatureSpan">karma.logger.</span>setup
        <span class="apidocSignatureSpan">(level, colors, appenders)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function (level, colors, appenders) {
  // Turn color on/off on the console appenders with pattern layout
  var pattern = colors ? constant.COLOR_PATTERN : constant.NO_COLOR_PATTERN

  // If there are no appenders use the default one
  appenders = helper.isDefined(appenders) ? appenders : [constant.CONSOLE_APPENDER]

  appenders = appenders.map(function (appender) {
    if (appender.type === 'console') {
      if (helper.isDefined(appender.layout) &amp;&amp; appender.layout.type === 'pattern') {
        appender.layout.pattern = pattern
      }
    }
    return appender
  })

  // Pass the values to log4js
  log4js.setGlobalLogLevel(level)
  log4js.configure({
    appenders: appenders
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    config.hostname = defaultHostname
  }
  if (config.listenAddress === null) {
    config.listenAddress = defaultListenAddress
  }

  // configure the logger as soon as we can
  logger.<span class="apidocCodeKeywordSpan">setup</span>(config.logLevel, config.colors, config.loggers)

  return normalizeConfig(config, configFilePath)
}

// PUBLIC API
exports.parseConfig = parseConfig
exports.Pattern = Pattern
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.logger.setupFromConfig" id="apidoc.element.karma.logger.setupFromConfig">
        function <span class="apidocSignatureSpan">karma.logger.</span>setupFromConfig
        <span class="apidocSignatureSpan">(config, appenders)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupFromConfig = function (config, appenders) {
  var useColors = true
  var logLevel = constant.LOG_INFO

  if (helper.isDefined(config.colors)) {
    useColors = config.colors
  }

  if (helper.isDefined(config.logLevel)) {
    logLevel = config.logLevel
  }
  setup(logLevel, useColors, appenders)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  processedAnswers.preprocessors['**/*.coffee'] = ['coffee']
}

return processedAnswers
}

exports.init = function (config) {
logger.<span class="apidocCodeKeywordSpan">setupFromConfig</span>(config)

var colorScheme = COLOR_SCHEME.ON

if (helper.isDefined(config.colors)) {
  colorScheme = config.colors ? COLOR_SCHEME.ON : COLOR_SCHEME.OFF
}
// need to be registered before creating readlineInterface
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.plugin" id="apidoc.module.karma.plugin">module karma.plugin</a></h1>


    <h2>
        <a href="#apidoc.element.karma.plugin.resolve" id="apidoc.element.karma.plugin.resolve">
        function <span class="apidocSignatureSpan">karma.plugin.</span>resolve
        <span class="apidocSignatureSpan">(plugins, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (plugins, emitter) {
  var modules = []

  var requirePlugin = function (name) {
    log.debug('Loading plugin %s.', name)
    try {
      modules.push(require(name))
    } catch (e) {
      if (e.code === 'MODULE_NOT_FOUND' &amp;&amp; e.message.indexOf(name) !== -1) {
        log.error('Cannot find plugin "%s".\n  Did you forget to install it?\n' +
          '  npm install %s --save-dev', name, name)
      } else {
        log.error('Error during loading "%s" plugin:\n  %s', name, e.message)
      }
      emitter.emit('load_error', 'plug_in', name)
    }
  }

  plugins.forEach(function (plugin) {
    if (helper.isString(plugin)) {
      if (plugin.indexOf('*') === -1) {
        requirePlugin(plugin)
        return
      }
      var pluginDirectory = path.normalize(path.join(__dirname, '/../..'))
      var regexp = new RegExp('^' + plugin.replace('*', '.*'))

      log.debug('Loading %s from %s', plugin, pluginDirectory)
      fs.readdirSync(pluginDirectory).filter(function (pluginName) {
        return IGNORED_PACKAGES.indexOf(pluginName) === -1 &amp;&amp; regexp.test(pluginName)
      }).forEach(function (pluginName) {
        requirePlugin(pluginDirectory + '/' + pluginName)
      })
      return
    }
    if (helper.isObject(plugin)) {
      log.debug('Loading inlined plugin (defining %s).', Object.keys(plugin).join(', '))
      modules.push(plugin)
      return
    }
    log.error('Invalid plugin %s', plugin)
    emitter.emit('load_error', 'plug_in', plugin)
  })

  return modules
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else if (fs.existsSync('./.config/karma.conf.coffee')) {
    configFile = './.config/karma.conf.coffee'
  } else if (fs.existsSync('./.config/karma.conf.ts')) {
    configFile = './.config/karma.conf.ts'
  }
}

options.configFile = configFile ? path.<span class="apidocCodeKeywordSpan">resolve</span>(configFile) : null

return options
}

var parseClientArgs = function (argv) {
// extract any args after '--' as clientArgs
var clientArgs = []
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.preprocessor" id="apidoc.module.karma.preprocessor">module karma.preprocessor</a></h1>


    <h2>
        <a href="#apidoc.element.karma.preprocessor.createPreprocessor" id="apidoc.element.karma.preprocessor.createPreprocessor">
        function <span class="apidocSignatureSpan">karma.preprocessor.</span>createPreprocessor
        <span class="apidocSignatureSpan">(config, basePath, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPreprocessor = function (config, basePath, injector) {
  var alreadyDisplayedErrors = {}
  var instances = {}
  var patterns = Object.keys(config)

  var emitter = injector.get('emitter')

  var instantiatePreprocessor = function (name) {
    if (alreadyDisplayedErrors[name]) {
      return
    }

    var p

    try {
      p = injector.get('preprocessor:' + name)
    } catch (e) {
      if (e.message.indexOf('No provider for "preprocessor:' + name + '"') !== -1) {
        log.error('Can not load "%s", it is not registered!\n  ' +
          'Perhaps you are missing some plugin?', name)
      } else {
        log.error('Can not load "%s"!\n  ' + e.stack, name)
      }
      alreadyDisplayedErrors[name] = true
      emitter.emit('load_error', 'preprocessor', name)
    }

    return p
  }

  var allPreprocessors = []
  patterns.forEach(function (pattern) {
    allPreprocessors = combineLists(allPreprocessors, config[pattern])
  })
  allPreprocessors.forEach(instantiatePreprocessor)

  return function preprocess (file, done) {
    patterns = Object.keys(config)

    return fs.readFile(file.originalPath, function (err, buffer) {
      if (err) {
        throw err
      }

      isBinaryFile(buffer, buffer.length, function (err, thisFileIsBinary) {
        if (err) {
          throw err
        }

        var preprocessorNames = []
        for (var i = 0; i &lt; patterns.length; i++) {
          if (mm(file.originalPath, patterns[i], {dot: true})) {
            if (thisFileIsBinary) {
              log.warn('Ignoring preprocessing (%s) %s because it is a binary file.',
                config[patterns[i]].join(', '), file.originalPath)
            } else {
              preprocessorNames = combineLists(preprocessorNames, config[patterns[i]])
            }
          }
        }

        var preprocessors = []
        var nextPreprocessor = createNextProcessor(preprocessors, file, done)
        preprocessorNames.forEach(function (name) {
          var p = instances[name]
          if (p == null) {
            p = instantiatePreprocessor(name)
          }

          if (p == null) {
            if (!alreadyDisplayedErrors[name]) {
              alreadyDisplayedErrors[name] = true
              log.error('Failed to instantiate preprocessor %s', name)
              emitter.emit('load_error', 'preprocessor', name)
            }
            return
          }

          instances[name] = p
          preprocessors.push(p)
        })

        nextPreprocessor(null, thisFileIsBinary ? buffer : buffer.toString())
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.process" id="apidoc.module.karma.process">module karma.process</a></h1>


    <h2>
        <a href="#apidoc.element.karma.process.process" id="apidoc.element.karma.process.process">
        function <span class="apidocSignatureSpan">karma.</span>process
        <span class="apidocSignatureSpan">(spawn, tempDir, timer, processKillTimeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (spawn, tempDir, timer, processKillTimeout) {
  var self = this
  var onExitCallback
  var killTimeout = processKillTimeout || 2000

  this._tempDir = tempDir.getPath('/karma-' + this.id.toString())

  this.on('start', function (url) {
    tempDir.create(self._tempDir)
    self._start(url)
  })

  this.on('kill', function (done) {
    if (!self._process) {
      return process.nextTick(done)
    }

    onExitCallback = done
    self._process.kill()
    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout)
  })

  this._start = function (url) {
    self._execCommand(self._getCommand(), self._getOptions(url))
  }

  this._getCommand = function () {
    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform]
  }

  this._getOptions = function (url) {
    return [url]
  }

  // Normalize the command, remove quotes (spawn does not like them).
  this._normalizeCommand = function (cmd) {
    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) &amp;&amp; '\'`"'.indexOf(cmd.charAt(0)) !== -1) {
      cmd = cmd.substring(1, cmd.length - 1)
      log.warn('The path should not be quoted.\n  Normalized the path to %s', cmd)
    }

    return path.normalize(cmd)
  }

  this._execCommand = function (cmd, args) {
    if (!cmd) {
      log.error('No binary for %s browser on your platform.\n  ' +
        'Please, set "%s" env variable.', self.name, self.ENV_CMD)

      // disable restarting
      self._retryLimit = -1

      return self._clearTempDirAndReportDone('no binary')
    }

    cmd = this._normalizeCommand(cmd)

    log.debug(cmd + ' ' + args.join(' '))
    self._process = spawn(cmd, args)

    var errorOutput = ''

    self._process.on('exit', function (code) {
      self._onProcessExit(code, errorOutput)
    })

    self._process.on('error', function (err) {
      if (err.code === 'ENOENT') {
        self._retryLimit = -1
        errorOutput = 'Can not find the binary ' + cmd + '\n\t' +
          'Please set env variable ' + self.ENV_CMD
      } else {
        errorOutput += err.toString()
      }
    })

    self._process.stderr.on('data', function (errBuff) {
      errorOutput += errBuff.toString()
    })
  }

  this._onProcessExit = function (code, errorOutput) {
    log.debug('Process %s exited with code %d', self.name, code)

    var error = null

    if (self.state === self.STATE_BEING_CAPTURED) {
      log.error('Cannot start %s\n\t%s', self.name, errorOutput)
      error = 'cannot start'
    }

    if (self.state === self.STATE_CAPTURED) {
      log.error('%s crashed.\n\t%s', self.name, errorOutput)
      error = 'crashed'
    }

    self._process = null
    if (self._killTimer) {
      timer.clearTimeout(self._killTimer)
      self._killTimer = null
    }
    self._clearTempDirAndReportDone(error)
  }

  this._clearTempDirAndReportDone = function (error) {
    tempDir.remove(self._tempDir, function () {
      self._done(error)
      if (onExitCallback) {
        onExitCallback()
        onExitCallback = null
      }
    })
  }

  this._onKillTimeout = function () {
    if (self.state !== self.STATE_BEING_KILLED &amp;&amp; self.state !== self.STATE_BEING_FORCE_KILLED) {
      return
    }

    log.warn('%s was not killed in %d ms, sending SIGKILL.', self.name, killTimeout)
    self._process.kill('SIGKILL')

    // NOTE: https://github.com/karma-runner/karma/pull/1184
    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.
    // If a process gets into a state where it doesn't respond in a reasonable amount of time
    // Karma should warn, and continue as though the kill succeeded.
    // This a certainly suboptimal, but it is better than having the test harness hang waiting
    // for a zombie child process to exit.
    self._killTimer = timer.setTimeout(function () {
      log.warn('%s was not killed by SIGKILL in %d ms, continuing.', self.name, killTimeout)
      self._onProcessExit(-1, '')
    }, killTimeout)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    process.exit(1)
}

return processArgs(argv, options, fs, path)
}

exports.run = function () {
var config = exports.<span class="apidocCodeKeywordSpan">process</span>()

switch (config.cmd) {
  case 'start':
    new Server(config).start()
    break
  case 'run':
    require('./runner').run(config)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.process.decoratorFactory" id="apidoc.element.karma.process.decoratorFactory">
        function <span class="apidocSignatureSpan">karma.process.</span>decoratorFactory
        <span class="apidocSignatureSpan">(timer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decoratorFactory = function (timer) {
  return function (launcher, processKillTimeout) {
    var spawn = require('child_process').spawn

    var spawnWithoutOutput = function () {
      var proc = spawn.apply(null, arguments)
      proc.stdout.resume()
      proc.stderr.resume()

      return proc
    }

    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.proxy" id="apidoc.module.karma.proxy">module karma.proxy</a></h1>


    <h2>
        <a href="#apidoc.element.karma.proxy.create" id="apidoc.element.karma.proxy.create">
        function <span class="apidocSignatureSpan">karma.proxy.</span>create
        <span class="apidocSignatureSpan">(config, proxies)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (config, proxies) {
  return createProxyHandler(parseProxyConfig(proxies, config), config.urlRoot)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The browser got permanently disconnected (being removed from the collection and destroyed).
var DISCONNECTED = 5

var Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,
/* config.browserDisconnectTimeout */ disconnectDelay,
/* config.browserNoActivityTimeout */ noActivityTimeout) {
var name = helper.browserFullNameToShort(fullName)
var log = logger.<span class="apidocCodeKeywordSpan">create</span>(name)
var activeSockets = [socket]
var activeSocketsIds = function () {
  return activeSockets.map(function (s) {
    return s.id
  }).join(', ')
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.reporter" id="apidoc.module.karma.reporter">module karma.reporter</a></h1>


    <h2>
        <a href="#apidoc.element.karma.reporter.createReporters" id="apidoc.element.karma.reporter.createReporters">
        function <span class="apidocSignatureSpan">karma.reporter.</span>createReporters
        <span class="apidocSignatureSpan">(names, config, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createReporters = function (names, config, emitter, injector) {
  var errorFormatter = createErrorFormatter(config, emitter, SourceMapConsumer)
  var reporters = []

  // TODO(vojta): instantiate all reporters through DI
  names.forEach(function (name) {
    if (['dots', 'progress'].indexOf(name) !== -1) {
      var Cls = require('./reporters/' + name)
      var ClsColor = require('./reporters/' + name + '_color')
      reporters.push(new Cls(errorFormatter, config.reportSlowerThan, config.colors, config.browserConsoleLogOptions))
      return reporters.push(new ClsColor(errorFormatter, config.reportSlowerThan, config.colors, config.browserConsoleLogOptions
))
    }

    var locals = {
      baseReporterDecorator: ['factory', baseReporterDecoratorFactory],
      formatError: ['value', errorFormatter]
    }

    try {
      log.debug('Trying to load reporter: %s', name)
      reporters.push(injector.createChild([locals], ['reporter:' + name]).get('reporter:' + name))
    } catch (e) {
      if (e.message.indexOf('No provider for "reporter:' + name + '"') !== -1) {
        log.error('Can not load reporter "%s", it is not registered!\n  ' +
          'Perhaps you are missing some plugin?', name)
      } else {
        log.error('Can not load "%s"!\n  ' + e.stack, name)
      }
      emitter.emit('load_error', 'reporter', name)
      return
    }
    var colorName = name + '_color'
    if (names.indexOf(colorName) !== -1) {
      return
    }
    try {
      log.debug('Trying to load color-version of reporter: %s (%s)', name, colorName)
      reporters.push(injector.createChild([locals], ['reporter:' + name + '_color']).get('reporter:' + name))
    } catch (e) {
      log.debug('Couldn\'t load color-version.')
    }
  })

  // bind all reporters
  reporters.forEach(function (reporter) {
    emitter.bind(reporter)
  })

  return new MultiReporter(reporters)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.retry" id="apidoc.module.karma.retry">module karma.retry</a></h1>


    <h2>
        <a href="#apidoc.element.karma.retry.retry" id="apidoc.element.karma.retry.retry">
        function <span class="apidocSignatureSpan">karma.</span>retry
        <span class="apidocSignatureSpan">(retryLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function (retryLimit) {
  var self = this

  this._retryLimit = retryLimit

  this.on('done', function () {
    if (!self.error) {
      return
    }

    if (self._retryLimit &gt; 0) {
      var attempt = retryLimit - self._retryLimit + 1
      log.info('Trying to start %s again (%d/%d).', self.name, attempt, retryLimit)
      self.restart()
      self._retryLimit--
    } else if (self._retryLimit === 0) {
      log.error('%s failed %d times (%s). Giving up.', self.name, retryLimit, self.error)
    } else {
      log.debug('%s failed (%s). Not restarting.', self.name, self.error)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.retry.decoratorFactory" id="apidoc.element.karma.retry.decoratorFactory">
        function <span class="apidocSignatureSpan">karma.retry.</span>decoratorFactory
        <span class="apidocSignatureSpan">(retryLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decoratorFactory = function (retryLimit) {
  return function (launcher) {
    RetryLauncher.call(launcher, retryLimit)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.runner" id="apidoc.module.karma.runner">module karma.runner</a></h1>


    <h2>
        <a href="#apidoc.element.karma.runner.run" id="apidoc.element.karma.runner.run">
        function <span class="apidocSignatureSpan">karma.runner.</span>run
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (config, done) {
  config = config || {}

  logger.setupFromConfig(config)

  done = helper.isFunction(done) ? done : process.exit
  config = cfg.parseConfig(config.configFile, config)

  var exitCode = 1
  var options = {
    hostname: config.hostname,
    path: config.urlRoot + 'run',
    port: config.port,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    }
  }

  var request = http.request(options, function (response) {
    response.on('data', function (buffer) {
      var parsedResult = parseExitCode(buffer, exitCode, config.failOnEmptyTestSuite)
      exitCode = parsedResult.exitCode
      process.stdout.write(parsedResult.buffer)
    })

    response.on('end', function () {
      done(exitCode)
    })
  })

  request.on('error', function (e) {
    if (e.code === 'ECONNREFUSED') {
      log.error('There is no server listening on port %d', options.port)
      done(1, e.code)
    } else {
      throw e
    }
  })

  request.end(JSON.stringify({
    args: config.clientArgs,
    removedFiles: config.removedFiles,
    changedFiles: config.changedFiles,
    addedFiles: config.addedFiles,
    refresh: config.refresh,
    colors: config.colors
  }))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
require('load-grunt-tasks')(grunt)

grunt.registerTask('build', ['browserify:client'])
grunt.registerTask('default', ['build', 'test', 'lint'])
grunt.registerTask('test-appveyor', ['test:unit', 'test:client'])

grunt.registerTask('release', 'Build, bump and publish to NPM.', function (type) {
  grunt.task.<span class="apidocCodeKeywordSpan">run</span>([
    'npm-contributors',
    'bump:' + (type || 'patch') + ':bump-only',
    'build',
    'conventionalChangelog',
    'bump-commit',
    'conventionalGithubReleaser',
    'npm-publish'
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.server" id="apidoc.module.karma.server">module karma.server</a></h1>


    <h2>
        <a href="#apidoc.element.karma.server.start" id="apidoc.element.karma.server.start">
        function <span class="apidocSignatureSpan">karma.server.</span>start
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cliOptions, done) {
  console.error('WARN `start` method is deprecated since 0.13. It will be removed in 0.14. Please use \n' +
    '  server = new Server(config, [done])\n' +
    '  server.start()\n' +
    'instead.')
  var server = new Server(cliOptions, done)
  server.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var UNIMPLEMENTED_START = function () {
  this.error('You need to include some adapter that implements __karma__.start method!')
}
// all files loaded, let's start the execution
this.loaded = function () {
  // has error -&gt; cancel
  if (!hasError) {
    this.<span class="apidocCodeKeywordSpan">start</span>(this.config)
  }

  // remove reference to child iframe
  this.start = UNIMPLEMENTED_START
}
// supposed to be overriden by the context
// TODO(vojta): support multiple callbacks (queue)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.source_files" id="apidoc.module.karma.source_files">module karma.source_files</a></h1>


    <h2>
        <a href="#apidoc.element.karma.source_files.create" id="apidoc.element.karma.source_files.create">
        function <span class="apidocSignatureSpan">karma.source_files.</span>create
        <span class="apidocSignatureSpan">(filesPromise, serveFile, basePath, urlRoot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (filesPromise, serveFile, basePath, urlRoot) {
  return function (request, response, next) {
    var requestedFilePath = composeUrl(request.url, basePath, urlRoot, true)
    // When a path contains HTML-encoded characters (e.g %2F used by Jenkins for branches with /)
    var requestedFilePathUnescaped = composeUrl(request.url, basePath, urlRoot, false)

    request.pause()

    log.debug('Requesting %s', request.url, urlRoot)
    log.debug('Fetching %s', requestedFilePath)

    return filesPromise.then(function (files) {
      // TODO(vojta): change served to be a map rather then an array
      var file = findByPath(files.served, requestedFilePath) ||
                 findByPath(files.served, requestedFilePathUnescaped)
      var rangeHeader = request.headers['range']

      if (file) {
        serveFile(file.contentPath || file.path, rangeHeader, response, function () {
          if (/\?\w+/.test(request.url)) {
            // files with timestamps - cache one year, rely on timestamps
            common.setHeavyCacheHeaders(response)
          } else {
            // without timestamps - no cache (debug)
            common.setNoCacheHeaders(response)
          }
        }, file.content, file.doNotCache)
      } else {
        next()
      }

      request.resume()
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The browser got permanently disconnected (being removed from the collection and destroyed).
var DISCONNECTED = 5

var Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,
/* config.browserDisconnectTimeout */ disconnectDelay,
/* config.browserNoActivityTimeout */ noActivityTimeout) {
var name = helper.browserFullNameToShort(fullName)
var log = logger.<span class="apidocCodeKeywordSpan">create</span>(name)
var activeSockets = [socket]
var activeSocketsIds = function () {
  return activeSockets.map(function (s) {
    return s.id
  }).join(', ')
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.state_machine" id="apidoc.module.karma.state_machine">module karma.state_machine</a></h1>


    <h2>
        <a href="#apidoc.element.karma.state_machine.state_machine" id="apidoc.element.karma.state_machine.state_machine">
        function <span class="apidocSignatureSpan">karma.</span>state_machine
        <span class="apidocSignatureSpan">(rli, colors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">state_machine = function (rli, colors) {
  var questions
  var currentQuestion
  var answers
  var currentOptions
  var currentOptionsPointer
  var currentQuestionId
  var done

  EventEmitter.call(this)

  var showPrompt = function () {
    rli.write(colors.ANSWER)
    rli.prompt()
  }

  this.onKeypress = function (key) {
    if (!currentOptions || !key) {
      return
    }

    if (key.name === 'tab' || key.name === 'right' || key.name === 'down') {
      this.suggestNextOption()
    } else if (key.name === 'left' || key.name === 'up') {
      currentOptionsPointer = currentOptionsPointer + currentOptions.length - 2
      this.suggestNextOption()
    }

    if (!key.ctrl &amp;&amp; !key.meta &amp;&amp; key.name !== 'enter' &amp;&amp; key.name !== 'return') {
      key.name = 'escape'
    }
  }

  this.suggestNextOption = function () {
    if (!currentOptions) {
      return
    }

    currentOptionsPointer = (currentOptionsPointer + 1) % currentOptions.length
    rli._deleteLineLeft()
    rli._deleteLineRight()
    rli.write(currentOptions[currentOptionsPointer])
  }

  this.kill = function () {
    currentOptions = null
    currentQuestionId = null
    rli.write('\n' + colors.RESET + '\n')
    rli.close()
  }

  this.onLine = function (line) {
    if (currentQuestionId) {
      rli.write(colors.RESET)
      line = line.trim().replace(colors.ANSWER, '').replace(colors.RESET, '')

      if (currentOptions) {
        currentOptionsPointer = currentOptions.indexOf(line)
        if (currentOptionsPointer === -1) {
          return
        }
      }

      if (line === '') {
        line = null
      }

      if (currentQuestion.boolean) {
        line = (line === 'yes' || line === 'true' || line === 'on')
      }

      if (line !== null &amp;&amp; currentQuestion.validate) {
        currentQuestion.validate(line)
      }

      if (currentQuestion.multiple) {
        answers[currentQuestionId] = answers[currentQuestionId] || []
        if (line !== null) {
          answers[currentQuestionId].push(line)
          showPrompt()

          if (currentOptions) {
            currentOptions.splice(currentOptionsPointer, 1)
            currentOptionsPointer = -1
          }
        } else {
          this.nextQuestion()
        }
      } else {
        answers[currentQuestionId] = line
        this.nextQuestion()
      }
    }
  }

  this.nextQuestion = function () {
    currentQuestion = questions.shift()

    while (currentQuestion &amp;&amp; currentQuestion.condition &amp;&amp; !currentQuestion.condition(answers)) {
      currentQuestion = questions.shift()
    }

    this.emit('next_question', currentQuestion)

    if (currentQuestion) {
      currentQuestionId = null

      rli.write('\n' + colors.question(currentQuestion.question) + '\n')
      rli.write(currentQuestion.hint + '\n')
      showPrompt()

      currentOptions = currentQuestion.options || null
      currentOptionsPointer = -1
      currentQuestionId = currentQuestion.id

      this.suggestNextOption()
    } else {
      currentQuestionId = null
      currentOptions = null

      // end
      this.kill()
      done(answers)
    }
  }

  this.process = function (_questions, _done) {
    questions = _questions
    answers = {}
    done = _done

    this.nextQuestion()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.state_machine.super_" id="apidoc.element.karma.state_machine.super_">
        function <span class="apidocSignatureSpan">karma.state_machine.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.stopper" id="apidoc.module.karma.stopper">module karma.stopper</a></h1>


    <h2>
        <a href="#apidoc.element.karma.stopper.stop" id="apidoc.element.karma.stopper.stop">
        function <span class="apidocSignatureSpan">karma.stopper.</span>stop
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (config, done) {
  config = config || {}
  logger.setupFromConfig(config)
  done = helper.isFunction(done) ? done : process.exit
  var log = logger.create('stopper')
  config = cfg.parseConfig(config.configFile, config)

  var options = {
    hostname: config.hostname,
    path: config.urlRoot + 'stop',
    port: config.port,
    method: 'GET'
  }

  var request = http.request(options)

  request.on('response', function (response) {
    if (response.statusCode !== 200) {
      log.error('Server returned status code: ' + response.statusCode)
      done(1)
      return
    }

    log.info('Server stopped.')
    done(0)
  })

  request.on('error', function (e) {
    if (e.code === 'ECONNREFUSED') {
      log.error('There is no server listening on port %d', options.port)
      done(1, e.code)
    } else {
      throw e
    }
  })
  request.end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'start':
  new Server(config).start()
  break
case 'run':
  require('./runner').run(config)
  break
case 'stop':
  require('./stopper').<span class="apidocCodeKeywordSpan">stop</span>(config)
  break
case 'init':
  require('./init').init(config)
  break
case 'completion':
  require('./completion').completion(config)
  break
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.strip_host" id="apidoc.module.karma.strip_host">module karma.strip_host</a></h1>


    <h2>
        <a href="#apidoc.element.karma.strip_host.create" id="apidoc.element.karma.strip_host.create">
        function <span class="apidocSignatureSpan">karma.strip_host.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function () {
  return function (request, response, next) {
    function stripHostFromUrl (url) {
      return url.replace(/^http[s]?:\/\/([a-z\-.:\d]+)\//, '/')
    }

    request.normalizedUrl = stripHostFromUrl(request.url) || request.url
    next()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The browser got permanently disconnected (being removed from the collection and destroyed).
var DISCONNECTED = 5

var Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,
/* config.browserDisconnectTimeout */ disconnectDelay,
/* config.browserNoActivityTimeout */ noActivityTimeout) {
var name = helper.browserFullNameToShort(fullName)
var log = logger.<span class="apidocCodeKeywordSpan">create</span>(name)
var activeSockets = [socket]
var activeSocketsIds = function () {
  return activeSockets.map(function (s) {
    return s.id
  }).join(', ')
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.temp_dir" id="apidoc.module.karma.temp_dir">module karma.temp_dir</a></h1>


    <h2>
        <a href="#apidoc.element.karma.temp_dir.create" id="apidoc.element.karma.temp_dir.create">
        function <span class="apidocSignatureSpan">karma.temp_dir.</span>create
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (path) {
  log.debug('Creating temp dir at %s', path)

  try {
    fs.mkdirSync(path)
  } catch (e) {
    log.warn('Failed to create a temp dir at %s', path)
  }

  return path
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The browser got permanently disconnected (being removed from the collection and destroyed).
var DISCONNECTED = 5

var Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,
/* config.browserDisconnectTimeout */ disconnectDelay,
/* config.browserNoActivityTimeout */ noActivityTimeout) {
var name = helper.browserFullNameToShort(fullName)
var log = logger.<span class="apidocCodeKeywordSpan">create</span>(name)
var activeSockets = [socket]
var activeSocketsIds = function () {
  return activeSockets.map(function (s) {
    return s.id
  }).join(', ')
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.temp_dir.getPath" id="apidoc.element.karma.temp_dir.getPath">
        function <span class="apidocSignatureSpan">karma.temp_dir.</span>getPath
        <span class="apidocSignatureSpan">(suffix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPath = function (suffix) {
  return path.normalize(TEMP_DIR + suffix)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var env = process.env

var ProcessLauncher = function (spawn, tempDir, timer, processKillTimeout) {
var self = this
var onExitCallback
var killTimeout = processKillTimeout || 2000

this._tempDir = tempDir.<span class="apidocCodeKeywordSpan">getPath</span>('/karma-' + this.id.toString())

this.on('start', function (url) {
  tempDir.create(self._tempDir)
  self._start(url)
})

this.on('kill', function (done) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.temp_dir.remove" id="apidoc.element.karma.temp_dir.remove">
        function <span class="apidocSignatureSpan">karma.temp_dir.</span>remove
        <span class="apidocSignatureSpan">(path, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (path, done) {
  log.debug('Cleaning temp dir %s', path)
  rimraf(path, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this
var pendingDisconnect
var disconnect = function (reason) {
  self.state = DISCONNECTED
  self.disconnectsCount++
  log.warn('Disconnected (%d times)' + (reason || ''), self.disconnectsCount)
  emitter.emit('browser_error', self, 'Disconnected' + reason)
  collection.<span class="apidocCodeKeywordSpan">remove</span>(self)
}

var noActivityTimeoutId
var refreshNoActivityTimeout = noActivityTimeout ? function () {
  clearNoActivityTimeout()
  noActivityTimeoutId = timer.setTimeout(function () {
    self.lastResult.totalTimeEnd()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.url" id="apidoc.module.karma.url">module karma.url</a></h1>


    <h2>
        <a href="#apidoc.element.karma.url.url" id="apidoc.element.karma.url.url">
        function <span class="apidocSignatureSpan">karma.</span>url
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">url = function (path) {
  this.path = path
  this.isUrl = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.url.prototype" id="apidoc.module.karma.url.prototype">module karma.url.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.karma.url.prototype.toString" id="apidoc.element.karma.url.prototype.toString">
        function <span class="apidocSignatureSpan">karma.url.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.path
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return "'" + obj + "'"
case 'undefined':
  return 'undefined'
case 'function':
  try {
    // function abc(a, b, c) { /* code goes here */ }
    //   -&gt; function abc(a, b, c) { ... }
    return obj.<span class="apidocCodeKeywordSpan">toString</span>().replace(/\{[\s\S]*\}/, '{ ... }')
  } catch (err) {
    if (err instanceof TypeError) {
      // Proxy(function abc(...) { ... })
      return 'Proxy(function ' + (obj.name || '') + '(...) { ... })'
    } else {
      throw err
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.util" id="apidoc.module.karma.util">module karma.util</a></h1>


    <h2>
        <a href="#apidoc.element.karma.util.elm" id="apidoc.element.karma.util.elm">
        function <span class="apidocSignatureSpan">karma.util.</span>elm
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elm = function (id) {
  return document.getElementById(id)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.util.generateId" id="apidoc.element.karma.util.generateId">
        function <span class="apidocSignatureSpan">karma.util.</span>generateId
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateId = function (prefix) {
  return prefix + Math.floor(Math.random() * 10000)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.util.instanceOf" id="apidoc.element.karma.util.instanceOf">
        function <span class="apidocSignatureSpan">karma.util.</span>instanceOf
        <span class="apidocSignatureSpan">(value, constructorName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">instanceOf = function (value, constructorName) {
  return Object.prototype.toString.apply(value) === '[object ' + constructorName + ']'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.util.isDefined" id="apidoc.element.karma.util.isDefined">
        function <span class="apidocSignatureSpan">karma.util.</span>isDefined
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDefined = function (value) {
  return !exports.isUndefined(value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  this.onInfo = function (info) {
if (this.isReady()) {
  return
}

// TODO(vojta): remove
if (helper.<span class="apidocCodeKeywordSpan">isDefined</span>(info.dump)) {
  emitter.emit('browser_log', this, info.dump, 'dump')
}

if (helper.isDefined(info.log)) {
  emitter.emit('browser_log', this, info.log, info.type)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.util.isUndefined" id="apidoc.element.karma.util.isUndefined">
        function <span class="apidocSignatureSpan">karma.util.</span>isUndefined
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isUndefined = function (value) {
  return typeof value === 'undefined'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

exports.isUndefined = function (value) {
return typeof value === 'undefined'
}

exports.isDefined = function (value) {
return !exports.<span class="apidocCodeKeywordSpan">isUndefined</span>(value)
}

exports.parseQueryParams = function (locationSearch) {
var params = {}
var pairs = locationSearch.substr(1).split('&amp;')
var keyValue
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.util.parseQueryParams" id="apidoc.element.karma.util.parseQueryParams">
        function <span class="apidocSignatureSpan">karma.util.</span>parseQueryParams
        <span class="apidocSignatureSpan">(locationSearch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseQueryParams = function (locationSearch) {
  var params = {}
  var pairs = locationSearch.substr(1).split('&amp;')
  var keyValue

  for (var i = 0; i &lt; pairs.length; i++) {
    keyValue = pairs[i].split('=')
    params[decodeURIComponent(keyValue[0])] = decodeURIComponent(keyValue[1])
  }

  return params
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.watcher" id="apidoc.module.karma.watcher">module karma.watcher</a></h1>


    <h2>
        <a href="#apidoc.element.karma.watcher.watch" id="apidoc.element.karma.watcher.watch">
        function <span class="apidocSignatureSpan">karma.watcher.</span>watch
        <span class="apidocSignatureSpan">(patterns, excludes, fileList, usePolling, emitter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (patterns, excludes, fileList, usePolling, emitter) {
  var watchedPatterns = getWatchedPatterns(patterns)
  var options = {
    usePolling: usePolling,
    ignorePermissionErrors: true,
    ignoreInitial: true,
    ignored: createIgnore(watchedPatterns, excludes)
  }
  var chokidarWatcher = new chokidar.FSWatcher(options)

  watchPatterns(watchedPatterns, chokidarWatcher)

  var bind = function (fn) {
    return function (path) {
      return fn.call(fileList, helper.normalizeWinPath(path))
    }
  }

  // register events
  chokidarWatcher.on('add', bind(fileList.addFile))
    .on('change', bind(fileList.changeFile))
    .on('unlink', bind(fileList.removeFile))
    // If we don't subscribe; unhandled errors from Chokidar will bring Karma down
    // (see GH Issue #959)
    .on('error', function (e) {
      log.debug(e)
    })

  emitter.on('exit', function (done) {
    chokidarWatcher.close()
    done()
  })

  return chokidarWatcher
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.web_server" id="apidoc.module.karma.web_server">module karma.web_server</a></h1>


    <h2>
        <a href="#apidoc.element.karma.web_server.create" id="apidoc.element.karma.web_server.create">
        function <span class="apidocSignatureSpan">karma.web_server.</span>create
        <span class="apidocSignatureSpan">(injector, emitter, fileList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (injector, emitter, fileList) {
  var config = injector.get('config')
  common.initializeMimeTypes(config)
  var serveStaticFile = common.createServeFile(fs, path.normalize(path.join(__dirname, '/../static')), config)
  var serveFile = common.createServeFile(fs, null, config)
  var filesPromise = new common.PromiseContainer()

  // Set an empty list of files to avoid race issues with
  // file_list_modified not having been emitted yet
  filesPromise.set(Promise.resolve(fileList.files))

  emitter.on('file_list_modified', function (files) {
    filesPromise.set(Promise.resolve(files))
  })

  // locals for webserver module
  // NOTE(vojta): figure out how to do this with DI
  injector = injector.createChild([{
    serveFile: ['value', serveFile],
    serveStaticFile: ['value', serveStaticFile],
    filesPromise: ['value', filesPromise]
  }])

  var proxyMiddlewareInstance = injector.invoke(proxyMiddleware.create)

  log.debug('Instantiating middleware')
  var handler = connect()

  if (config.beforeMiddleware) {
    config.beforeMiddleware.forEach(function (middleware) {
      handler.use(injector.get('middleware:' + middleware))
    })
  }

  handler.use(injector.invoke(runnerMiddleware.create))
  handler.use(injector.invoke(stopperMiddleware.create))
  handler.use(injector.invoke(stripHostMiddleware.create))
  handler.use(injector.invoke(karmaMiddleware.create))
  handler.use(injector.invoke(sourceFilesMiddleware.create))
  // TODO(vojta): extract the proxy into a plugin
  handler.use(proxyMiddlewareInstance)
  // TODO(vojta): remove, this is only here because of karma-dart
  // we need a better way of custom handlers
  handler.use(injector.invoke(createCustomHandler))

  if (config.middleware) {
    config.middleware.forEach(function (middleware) {
      handler.use(injector.get('middleware:' + middleware))
    })
  }

  handler.use(function (request, response) {
    common.serve404(response, request.url)
  })

  var serverClass = http
  var serverArguments = [handler]

  if (config.protocol === 'https:') {
    serverClass = https
    serverArguments.unshift(config.httpsServerOptions || {})
  }

  if (config.httpModule) {
    serverClass = config.httpModule
  }

  var server = serverClass.createServer.apply(null, serverArguments)

  server.on('upgrade', function (req, socket, head) {
    log.debug('upgrade %s', req.url)
    proxyMiddlewareInstance.upgrade(req, socket, head)
  })

  return server
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The browser got permanently disconnected (being removed from the collection and destroyed).
var DISCONNECTED = 5

var Browser = function (id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,
/* config.browserDisconnectTimeout */ disconnectDelay,
/* config.browserNoActivityTimeout */ noActivityTimeout) {
var name = helper.browserFullNameToShort(fullName)
var log = logger.<span class="apidocCodeKeywordSpan">create</span>(name)
var activeSockets = [socket]
var activeSocketsIds = function () {
  return activeSockets.map(function (s) {
    return s.id
  }).join(', ')
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>