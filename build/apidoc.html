<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://karma-runner.github.io/"

    >karma (v1.6.0)</a>
</h1>
<h4>Spectacular Test Runner for JavaScript.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma">module karma</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server">
            function <span class="apidocSignatureSpan">karma.</span>Server
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_">
            function <span class="apidocSignatureSpan">karma.</span>Server.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.</span>launcher.Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>Server.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>launcher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>runner</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">karma.</span>stopper</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">karma.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server">module karma.Server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.Server">
            function <span class="apidocSignatureSpan">karma.</span>Server
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.start">
            function <span class="apidocSignatureSpan">karma.Server.</span>start
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_">
            function <span class="apidocSignatureSpan">karma.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server.prototype">module karma.Server.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._detach">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_detach
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._setUpLoadErrorListener">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_setUpLoadErrorListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype._start">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_start
            <span class="apidocSignatureSpan">(config, launcher, preprocess, fileList, capturedBrowsers, executor, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.get">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>get
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.refreshFiles">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>refreshFiles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.prototype.start">
            function <span class="apidocSignatureSpan">karma.Server.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.Server.super_">module karma.Server.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.Server.super_.super_">
            function <span class="apidocSignatureSpan">karma.Server.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.config">module karma.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.config.parseConfig">
            function <span class="apidocSignatureSpan">karma.config.</span>parseConfig
            <span class="apidocSignatureSpan">(configFilePath, cliOptions)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.launcher">module karma.launcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.launcher.Launcher">module karma.launcher.Launcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher.Launcher">
            function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
            <span class="apidocSignatureSpan">(server, emitter, injector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.launcher.Launcher.generateId">
            function <span class="apidocSignatureSpan">karma.launcher.Launcher.</span>generateId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.runner">module karma.runner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.runner.run">
            function <span class="apidocSignatureSpan">karma.runner.</span>run
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.server">module karma.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.server.start">
            function <span class="apidocSignatureSpan">karma.server.</span>start
            <span class="apidocSignatureSpan">(cliOptions, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.karma.stopper">module karma.stopper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.karma.stopper.stop">
            function <span class="apidocSignatureSpan">karma.stopper.</span>stop
            <span class="apidocSignatureSpan">(config, done)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma" id="apidoc.module.karma">module karma</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server" id="apidoc.element.karma.Server">
        function <span class="apidocSignatureSpan">karma.</span>Server
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (cliOptions, done) {
  EventEmitter.call(this)

  logger.setupFromConfig(cliOptions)

  this.log = logger.create()

  this.loadErrors = []

  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)

  var modules = [{
    helper: [&#x27;value&#x27;, helper],
    logger: [&#x27;value&#x27;, logger],
    done: [&#x27;value&#x27;, done || process.exit],
    emitter: [&#x27;value&#x27;, this],
    server: [&#x27;value&#x27;, this],
    launcher: [&#x27;type&#x27;, Launcher],
    config: [&#x27;value&#x27;, config],
    preprocess: [&#x27;factory&#x27;, preprocessor.createPreprocessor],
    fileList: [&#x27;type&#x27;, FileList],
    webServer: [&#x27;factory&#x27;, ws.create],
    socketServer: [&#x27;factory&#x27;, createSocketIoServer],
    executor: [&#x27;type&#x27;, Executor],
    // TODO(vojta): remove
    customFileHandlers: [&#x27;value&#x27;, []],
    // TODO(vojta): remove, once karma-dart does not rely on it
    customScriptTypes: [&#x27;value&#x27;, []],
    reporter: [&#x27;factory&#x27;, reporter.createReporters],
    capturedBrowsers: [&#x27;type&#x27;, BrowserCollection],
    args: [&#x27;value&#x27;, {}],
    timer: [&#x27;value&#x27;, {
      setTimeout: function () {
        return setTimeout.apply(root, arguments)
      },
      clearTimeout: function (timeoutId) {
        clearTimeout(timeoutId)
      }
    }]
  }]

  this._setUpLoadErrorListener()
  // Load the plugins
  modules = modules.concat(plugin.resolve(config.plugins, this))

  this._injector = new di.Injector(modules)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.super_" id="apidoc.element.karma.Server.super_">
        function <span class="apidocSignatureSpan">karma.</span>Server.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server.super_ = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
    // TODO(vojta): allow passing args
    // TODO(vojta): ignore/throw if listener call done() multiple times
    var pending = this.listeners(name).length
    var deferred = helper.defer()
    var done = function () {
      if (!--pending) {
        deferred.resolve()
      }
    }

    this.emit(name, done)

    if (!pending) {
      deferred.resolve()
    }

    return deferred.promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher" id="apidoc.element.karma.launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.</span>launcher.Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">launcher.Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &#x3c; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + &#x27;//&#x27; + hostname + &#x27;:&#x27; + port + urlRoot

      var locals = {
        id: [&#x27;value&#x27;, Launcher.generateId()],
        name: [&#x27;value&#x27;, name],
        processKillTimeout: [&#x27;value&#x27;, processKillTimeout],
        baseLauncherDecorator: [&#x27;factory&#x27;, baseDecorator],
        captureTimeoutLauncherDecorator: [&#x27;factory&#x27;, captureTimeoutDecorator],
        retryLauncherDecorator: [&#x27;factory&#x27;, retryDecorator],
        processLauncherDecorator: [&#x27;factory&#x27;, processDecorator],
        baseBrowserDecorator: [&#x27;factory&#x27;, baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf(&#x27;/&#x27;) !== -1) {
        name = &#x27;Script&#x27;
      }

      try {
        var browser = injector.createChild([locals], [&#x27;launcher:&#x27; + name]).get(&#x27;launcher:&#x27; + name)
      } catch (e) {
        if (e.message.indexOf(&#x27;No provider for &#x22;launcher:&#x27; + name + &#x27;&#x22;&#x27;) !== -1) {
          log.error(&#x27;Cannot load browser &#x22;%s&#x22;: it is not registered! &#x27; +
            &#x27;Perhaps you are missing some plugin?&#x27;, name)
        } else {
          log.error(&#x27;Cannot load browser &#x22;%s&#x22;!\n  &#x27; + e.stack, name)
        }

        emitter.emit(&#x27;load_error&#x27;, &#x27;launcher&#x27;, name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info(&#x27;Starting browser %s&#x27;, helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on(&#x27;browser_process_failure&#x27;, function () {
          done(browser.error)
        })

        browser.on(&#x27;done&#x27;, function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      &#x27;Launching browser%s %s with %s&#x27;,
      names.length &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;,
      names.join(&#x27;, &#x27;),
      concurrency === Infinity ? &#x27;unlimited concurrency&#x27; : &#x27;concurrency &#x27; + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on(&#x27;end&#x27;, function (err) {
      log.debug(&#x27;Finished all browsers&#x27;)

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    &#x27;config.browsers&#x27;,
    &#x27;config.concurrency&#x27;,
    &#x27;config.processKillTimeout&#x27;
  ]

  this.launchSingle.$inject = [
    &#x27;config.protocol&#x27;,
    &#x27;config.hostname&#x27;,
    &#x27;config.port&#x27;,
    &#x27;config.urlRoot&#x27;,
    &#x27;config.upstreamProxy&#x27;,
    &#x27;config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server" id="apidoc.module.karma.Server">module karma.Server</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.Server" id="apidoc.element.karma.Server.Server">
        function <span class="apidocSignatureSpan">karma.</span>Server
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Server = function (cliOptions, done) {
  EventEmitter.call(this)

  logger.setupFromConfig(cliOptions)

  this.log = logger.create()

  this.loadErrors = []

  var config = cfg.parseConfig(cliOptions.configFile, cliOptions)

  var modules = [{
    helper: [&#x27;value&#x27;, helper],
    logger: [&#x27;value&#x27;, logger],
    done: [&#x27;value&#x27;, done || process.exit],
    emitter: [&#x27;value&#x27;, this],
    server: [&#x27;value&#x27;, this],
    launcher: [&#x27;type&#x27;, Launcher],
    config: [&#x27;value&#x27;, config],
    preprocess: [&#x27;factory&#x27;, preprocessor.createPreprocessor],
    fileList: [&#x27;type&#x27;, FileList],
    webServer: [&#x27;factory&#x27;, ws.create],
    socketServer: [&#x27;factory&#x27;, createSocketIoServer],
    executor: [&#x27;type&#x27;, Executor],
    // TODO(vojta): remove
    customFileHandlers: [&#x27;value&#x27;, []],
    // TODO(vojta): remove, once karma-dart does not rely on it
    customScriptTypes: [&#x27;value&#x27;, []],
    reporter: [&#x27;factory&#x27;, reporter.createReporters],
    capturedBrowsers: [&#x27;type&#x27;, BrowserCollection],
    args: [&#x27;value&#x27;, {}],
    timer: [&#x27;value&#x27;, {
      setTimeout: function () {
        return setTimeout.apply(root, arguments)
      },
      clearTimeout: function (timeoutId) {
        clearTimeout(timeoutId)
      }
    }]
  }]

  this._setUpLoadErrorListener()
  // Load the plugins
  modules = modules.concat(plugin.resolve(config.plugins, this))

  this._injector = new di.Injector(modules)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.start" id="apidoc.element.karma.Server.start">
        function <span class="apidocSignatureSpan">karma.Server.</span>start
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cliOptions, done) {
  var server = new Server(cliOptions, done)
  server.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.super_" id="apidoc.element.karma.Server.super_">
        function <span class="apidocSignatureSpan">karma.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function () {
  this.bind = bindAllEvents

  this.emitAsync = function (name) {
    // TODO(vojta): allow passing args
    // TODO(vojta): ignore/throw if listener call done() multiple times
    var pending = this.listeners(name).length
    var deferred = helper.defer()
    var done = function () {
      if (!--pending) {
        deferred.resolve()
      }
    }

    this.emit(name, done)

    if (!pending) {
      deferred.resolve()
    }

    return deferred.promise
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server.prototype" id="apidoc.module.karma.Server.prototype">module karma.Server.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.prototype._detach" id="apidoc.element.karma.Server.prototype._detach">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_detach
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_detach = function (config, done) {
  var log = this.log
  var tmpFile = tmp.fileSync({keep: true})
  log.info(&#x27;Starting karma detached&#x27;)
  log.info(&#x27;Run &#x22;karma stop&#x22; to stop the server.&#x27;)
  log.debug(&#x27;Writing config to tmp-file %s&#x27;, tmpFile.name)
  config.detached = false
  try {
    fs.writeFileSync(tmpFile.name, JSON.stringify(config), &#x27;utf8&#x27;)
  } catch (e) {
    log.error(&#x22;Couldn&#x27;t write temporary configuration file&#x22;)
    done(1)
    return
  }
  var child = spawn(process.argv[0], [path.resolve(__dirname, &#x27;../lib/detached.js&#x27;), tmpFile.name], {
    detached: true,
    stdio: &#x27;ignore&#x27;
  })
  child.unref()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype._setUpLoadErrorListener" id="apidoc.element.karma.Server.prototype._setUpLoadErrorListener">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_setUpLoadErrorListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setUpLoadErrorListener = function () {
  var self = this
  self.on(&#x27;load_error&#x27;, function (type, name) {
    self.log.debug(&#x27;Registered a load error of type %s with name %s&#x27;, type, name)
    self.loadErrors.push([type, name])
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype._start" id="apidoc.element.karma.Server.prototype._start">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>_start
        <span class="apidocSignatureSpan">(config, launcher, preprocess, fileList, capturedBrowsers, executor, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_start = function (config, launcher, preprocess, fileList, capturedBrowsers, executor, done) {
  var self = this
  if (config.detached) {
    this._detach(config, done)
    return
  }

  self._fileList = fileList

  config.frameworks.forEach(function (framework) {
    self._injector.get(&#x27;framework:&#x27; + framework)
  })

  var webServer = self._injector.get(&#x27;webServer&#x27;)
  var socketServer = self._injector.get(&#x27;socketServer&#x27;)

  // A map of launched browsers.
  var singleRunDoneBrowsers = Object.create(null)

  // Passing fake event emitter, so that it does not emit on the global,
  // we don&#x27;t care about these changes.
  var singleRunBrowsers = new BrowserCollection(new EventEmitter())

  // Some browsers did not get captured.
  var singleRunBrowserNotCaptured = false

  webServer.on(&#x27;error&#x27;, function (e) {
    if (e.code === &#x27;EADDRINUSE&#x27;) {
      self.log.warn(&#x27;Port %d in use&#x27;, config.port)
      config.port++
      webServer.listen(config.port, config.listenAddress)
    } else {
      throw e
    }
  })

  var afterPreprocess = function () {
    if (config.autoWatch) {
      self._injector.invoke(watcher.watch)
    }

    webServer.listen(config.port, config.listenAddress, function () {
      self.log.info(&#x27;Karma v%s server started at %s//%s:%s%s&#x27;, constant.VERSION,
        config.protocol, config.listenAddress, config.port, config.urlRoot)

      self.emit(&#x27;listening&#x27;, config.port)
      if (config.browsers &#x26;&#x26; config.browsers.length) {
        self._injector.invoke(launcher.launch, launcher).forEach(function (browserLauncher) {
          singleRunDoneBrowsers[browserLauncher.id] = false
        })
      }
      var noLoadErrors = self.loadErrors.length
      if (noLoadErrors &#x3e; 0) {
        self.log.error(&#x27;Found %d load error%s&#x27;, noLoadErrors, noLoadErrors === 1 ? &#x27;&#x27; : &#x27;s&#x27;)
        process.exitCode = 1
        process.kill(process.pid, &#x27;SIGINT&#x27;)
      }
    })
  }

  fileList.refresh().then(afterPreprocess, afterPreprocess)

  self.on(&#x27;browsers_change&#x27;, function () {
    // TODO(vojta): send only to interested browsers
    socketServer.sockets.emit(&#x27;info&#x27;, capturedBrowsers.serialize())
  })

  self.on(&#x27;browser_register&#x27;, function (browser) {
    launcher.markCaptured(browser.id)

    // TODO(vojta): This is lame, browser can get captured and then
    // crash (before other browsers get captured).
    if (launcher.areAllCaptured()) {
      self.emit(&#x27;browsers_ready&#x27;)

      if (config.autoWatch) {
        executor.schedule()
      }
    }
  })

  if (config.browserConsoleLogOptions &#x26;&#x26; config.browserConsoleLogOptions.path) {
    var configLevel = config.browserConsoleLogOptions.level || &#x27;debug&#x27;
    var configFormat = config.browserConsoleLogOptions.format || &#x27;%b %T: %m&#x27;
    var configPath = config.browserConsoleLogOptions.path
    self.log.info(&#x27;Writing browser console to file: %s&#x27;, configPath)
    var browserLogFile = fs.openSync(configPath, &#x27;w+&#x27;)
    var levels = [&#x27;log&#x27;, &#x27;error&#x27;, &#x27;warn&#x27;, &#x27;info&#x27;, &#x27;debug&#x27;]
    self.on(&#x27;browser_log&#x27;, function (browser, message, level) {
      if (levels.indexOf(level.toLowerCase()) &#x3e; levels.indexOf(configLevel)) return
      if (!helper.isString(message)) {
        message = util.inspect(message, {showHidden: false, colors: false})
      }
      var logMap = {&#x27;%m&#x27;: message, &#x27;%t&#x27;: level.toLowerCase(), &#x27;%T&#x27;: level.toUpperCase(), &#x27;%b&#x27;: browser}
      var logString = configFormat.replace(/%[mtTb]/g, function (m) {
        return logMap[m]
      })
      self.log.debug(&#x27;Writing browser console line: %s&#x27;, logString)
      fs.write(browserLogFile, logString + &#x27;\n&#x27;)
    })
  }

  var EVENTS_TO_REPLY = [&#x27;start&#x27;, &#x27;info&#x27;, &#x27;karma_error&#x27;, &#x27;result&#x27;, &#x27;complete&#x27;]
  socketServer.sockets.on(&#x27;connection&#x27;, function (socket) {
    self.log.debug(&#x27;A browser has connected on socket &#x27; + socket.id)

    var replySocketEvents = events.bufferEvents(socket, EVENTS_TO_REPLY)

    socket.on(&#x27;complete&#x27;, function (data, ack) {
      ack()
    })

    socket.on(&#x27;register&#x27;, function (info) {
      var newBrowser
      var isRestart

      if (info.id) {
        newBrowser = capturedBrowsers.getById ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.get" id="apidoc.element.karma.Server.prototype.get">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>get
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (token) {
  return this._injector.get(token)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.refreshFiles" id="apidoc.element.karma.Server.prototype.refreshFiles">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>refreshFiles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refreshFiles = function () {
  if (!this._fileList) return Promise.resolve()

  return this._fileList.refresh()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.Server.prototype.start" id="apidoc.element.karma.Server.prototype.start">
        function <span class="apidocSignatureSpan">karma.Server.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function () {
  this._injector.invoke(this._start, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.Server.super_" id="apidoc.module.karma.Server.super_">module karma.Server.super_</a></h1>


    <h2>
        <a href="#apidoc.element.karma.Server.super_.super_" id="apidoc.element.karma.Server.super_.super_">
        function <span class="apidocSignatureSpan">karma.Server.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.config" id="apidoc.module.karma.config">module karma.config</a></h1>


    <h2>
        <a href="#apidoc.element.karma.config.parseConfig" id="apidoc.element.karma.config.parseConfig">
        function <span class="apidocSignatureSpan">karma.config.</span>parseConfig
        <span class="apidocSignatureSpan">(configFilePath, cliOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseConfig = function (configFilePath, cliOptions) {
  var configModule
  if (configFilePath) {
    log.debug(&#x27;Loading config %s&#x27;, configFilePath)

    try {
      configModule = require(configFilePath)
      if (typeof configModule === &#x27;object&#x27; &#x26;&#x26; typeof configModule.default !== &#x27;undefined&#x27;) {
        configModule = configModule.default
      }
    } catch (e) {
      if (e.code === &#x27;MODULE_NOT_FOUND&#x27; &#x26;&#x26; e.message.indexOf(configFilePath) !== -1) {
        log.error(&#x27;File %s does not exist!&#x27;, configFilePath)
      } else {
        log.error(&#x27;Invalid config file!\n  &#x27; + e.stack)

        var extension = path.extname(configFilePath)
        if (extension === &#x27;.coffee&#x27; &#x26;&#x26; !COFFEE_SCRIPT_AVAILABLE) {
          log.error(&#x27;You need to install CoffeeScript.\n&#x27; +
            &#x27;  npm install coffee-script --save-dev&#x27;)
        } else if (extension === &#x27;.ls&#x27; &#x26;&#x26; !LIVE_SCRIPT_AVAILABLE) {
          log.error(&#x27;You need to install LiveScript.\n&#x27; +
            &#x27;  npm install LiveScript --save-dev&#x27;)
        } else if (extension === &#x27;.ts&#x27; &#x26;&#x26; !TYPE_SCRIPT_AVAILABLE) {
          log.error(&#x27;You need to install TypeScript.\n&#x27; +
            &#x27;  npm install typescript ts-node --save-dev&#x27;)
        }
      }
      return process.exit(1)
    }
    if (!helper.isFunction(configModule)) {
      log.error(&#x27;Config file must export a function!\n&#x27; + CONFIG_SYNTAX_HELP)
      return process.exit(1)
    }
  } else {
    log.debug(&#x27;No config file specified.&#x27;)
    // if no config file path is passed, we define a dummy config module.
    configModule = function () {}
  }

  var config = new Config()

  // save and reset hostname and listenAddress so we can detect if the user
  // changed them
  var defaultHostname = config.hostname
  config.hostname = null
  var defaultListenAddress = config.listenAddress
  config.listenAddress = null

  // add the user&#x27;s configuration in
  config.set(cliOptions)

  try {
    configModule(config)
  } catch (e) {
    log.error(&#x27;Error in config file!\n&#x27;, e)
    return process.exit(1)
  }

  // merge the config from config file and cliOptions (precedence)
  config.set(cliOptions)

  // if the user changed listenAddress, but didn&#x27;t set a hostname, warn them
  if (config.hostname === null &#x26;&#x26; config.listenAddress !== null) {
    log.warn(&#x27;ListenAddress was set to %s but hostname was left as the default: &#x27; +
      &#x27;%s. If your browsers fail to connect, consider changing the hostname option.&#x27;,
      config.listenAddress, defaultHostname)
  }
  // restore values that weren&#x27;t overwritten by the user
  if (config.hostname === null) {
    config.hostname = defaultHostname
  }
  if (config.listenAddress === null) {
    config.listenAddress = defaultListenAddress
  }

  // configure the logger as soon as we can
  logger.setup(config.logLevel, config.colors, config.loggers)

  return normalizeConfig(config, configFilePath)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.launcher" id="apidoc.module.karma.launcher">module karma.launcher</a></h1>


    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher" id="apidoc.element.karma.launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &#x3c; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + &#x27;//&#x27; + hostname + &#x27;:&#x27; + port + urlRoot

      var locals = {
        id: [&#x27;value&#x27;, Launcher.generateId()],
        name: [&#x27;value&#x27;, name],
        processKillTimeout: [&#x27;value&#x27;, processKillTimeout],
        baseLauncherDecorator: [&#x27;factory&#x27;, baseDecorator],
        captureTimeoutLauncherDecorator: [&#x27;factory&#x27;, captureTimeoutDecorator],
        retryLauncherDecorator: [&#x27;factory&#x27;, retryDecorator],
        processLauncherDecorator: [&#x27;factory&#x27;, processDecorator],
        baseBrowserDecorator: [&#x27;factory&#x27;, baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf(&#x27;/&#x27;) !== -1) {
        name = &#x27;Script&#x27;
      }

      try {
        var browser = injector.createChild([locals], [&#x27;launcher:&#x27; + name]).get(&#x27;launcher:&#x27; + name)
      } catch (e) {
        if (e.message.indexOf(&#x27;No provider for &#x22;launcher:&#x27; + name + &#x27;&#x22;&#x27;) !== -1) {
          log.error(&#x27;Cannot load browser &#x22;%s&#x22;: it is not registered! &#x27; +
            &#x27;Perhaps you are missing some plugin?&#x27;, name)
        } else {
          log.error(&#x27;Cannot load browser &#x22;%s&#x22;!\n  &#x27; + e.stack, name)
        }

        emitter.emit(&#x27;load_error&#x27;, &#x27;launcher&#x27;, name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info(&#x27;Starting browser %s&#x27;, helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on(&#x27;browser_process_failure&#x27;, function () {
          done(browser.error)
        })

        browser.on(&#x27;done&#x27;, function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      &#x27;Launching browser%s %s with %s&#x27;,
      names.length &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;,
      names.join(&#x27;, &#x27;),
      concurrency === Infinity ? &#x27;unlimited concurrency&#x27; : &#x27;concurrency &#x27; + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on(&#x27;end&#x27;, function (err) {
      log.debug(&#x27;Finished all browsers&#x27;)

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    &#x27;config.browsers&#x27;,
    &#x27;config.concurrency&#x27;,
    &#x27;config.processKillTimeout&#x27;
  ]

  this.launchSingle.$inject = [
    &#x27;config.protocol&#x27;,
    &#x27;config.hostname&#x27;,
    &#x27;config.port&#x27;,
    &#x27;config.urlRoot&#x27;,
    &#x27;config.upstreamProxy&#x27;,
    &#x27;config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.launcher.Launcher" id="apidoc.module.karma.launcher.Launcher">module karma.launcher.Launcher</a></h1>


    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher.Launcher" id="apidoc.element.karma.launcher.Launcher.Launcher">
        function <span class="apidocSignatureSpan">karma.launcher.</span>Launcher
        <span class="apidocSignatureSpan">(server, emitter, injector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Launcher = function (server, emitter, injector) {
  this._browsers = []
  var lastStartTime
  var self = this

  var getBrowserById = function (id) {
    for (var i = 0; i &#x3c; self._browsers.length; i++) {
      if (self._browsers[i].id === id) {
        return self._browsers[i]
      }
    }

    return null
  }

  this.launchSingle = function (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {
    var self = this
    return function (name) {
      if (upstreamProxy) {
        protocol = upstreamProxy.protocol
        hostname = upstreamProxy.hostname
        port = upstreamProxy.port
        urlRoot = upstreamProxy.path + urlRoot.substr(1)
      }
      var url = protocol + &#x27;//&#x27; + hostname + &#x27;:&#x27; + port + urlRoot

      var locals = {
        id: [&#x27;value&#x27;, Launcher.generateId()],
        name: [&#x27;value&#x27;, name],
        processKillTimeout: [&#x27;value&#x27;, processKillTimeout],
        baseLauncherDecorator: [&#x27;factory&#x27;, baseDecorator],
        captureTimeoutLauncherDecorator: [&#x27;factory&#x27;, captureTimeoutDecorator],
        retryLauncherDecorator: [&#x27;factory&#x27;, retryDecorator],
        processLauncherDecorator: [&#x27;factory&#x27;, processDecorator],
        baseBrowserDecorator: [&#x27;factory&#x27;, baseBrowserDecoratorFactory]
      }

      // TODO(vojta): determine script from name
      if (name.indexOf(&#x27;/&#x27;) !== -1) {
        name = &#x27;Script&#x27;
      }

      try {
        var browser = injector.createChild([locals], [&#x27;launcher:&#x27; + name]).get(&#x27;launcher:&#x27; + name)
      } catch (e) {
        if (e.message.indexOf(&#x27;No provider for &#x22;launcher:&#x27; + name + &#x27;&#x22;&#x27;) !== -1) {
          log.error(&#x27;Cannot load browser &#x22;%s&#x22;: it is not registered! &#x27; +
            &#x27;Perhaps you are missing some plugin?&#x27;, name)
        } else {
          log.error(&#x27;Cannot load browser &#x22;%s&#x22;!\n  &#x27; + e.stack, name)
        }

        emitter.emit(&#x27;load_error&#x27;, &#x27;launcher&#x27;, name)
        return
      }

      // TODO(vojta): remove in v1.0 (BC for old launchers)
      if (!browser.forceKill) {
        browser.forceKill = function () {
          var me = this
          return new Promise(function (resolve) {
            me.kill(resolve)
          })
        }

        browser.restart = function () {
          var me = this
          this.kill(function () {
            me.start(url)
          })
        }
      }

      self.jobs.add(function (args, done) {
        log.info(&#x27;Starting browser %s&#x27;, helper.isDefined(browser.displayName) ? browser.displayName : browser.name)

        browser.on(&#x27;browser_process_failure&#x27;, function () {
          done(browser.error)
        })

        browser.on(&#x27;done&#x27;, function () {
          // We are not done if there was an error as first the retry takes
          // place which we catch with `browser_process_failure` if it fails
          if (browser.error || browser.state === browser.STATE_RESTARTING) return

          done(null, browser)
        })

        browser.start(url)
      }, [])

      self.jobs.run()
      self._browsers.push(browser)
    }
  }

  this.launch = function (names, concurrency) {
    log.info(
      &#x27;Launching browser%s %s with %s&#x27;,
      names.length &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;,
      names.join(&#x27;, &#x27;),
      concurrency === Infinity ? &#x27;unlimited concurrency&#x27; : &#x27;concurrency &#x27; + concurrency
    )
    this.jobs = new Jobs({maxConcurrency: concurrency})

    var self = this
    lastStartTime = Date.now()

    if (server.loadErrors.length === 0) {
      names.forEach(function (name) {
        injector.invoke(self.launchSingle, self)(name)
      })
    } else {
      // Empty task to ensure `end` is emitted
      this.jobs.add(function (args, done) {
        done()
      }, [])
    }

    this.jobs.on(&#x27;end&#x27;, function (err) {
      log.debug(&#x27;Finished all browsers&#x27;)

      if (err) {
        log.error(err)
      }
    })

    this.jobs.run()

    return self._browsers
  }

  this.launch.$inject = [
    &#x27;config.browsers&#x27;,
    &#x27;config.concurrency&#x27;,
    &#x27;config.processKillTimeout&#x27;
  ]

  this.launchSingle.$inject = [
    &#x27;config.protocol&#x27;,
    &#x27;config.hostname&#x27;,
    &#x27;config.port&#x27;,
    &#x27;config.urlRoot&#x27;,
    &#x27;config.upstreamProxy&#x27;,
    &#x27;config.proces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.karma.launcher.Launcher.generateId" id="apidoc.element.karma.launcher.Launcher.generateId">
        function <span class="apidocSignatureSpan">karma.launcher.Launcher.</span>generateId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateId = function () {
  return &#x27;&#x27; + Math.floor(Math.random() * 100000000)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.runner" id="apidoc.module.karma.runner">module karma.runner</a></h1>


    <h2>
        <a href="#apidoc.element.karma.runner.run" id="apidoc.element.karma.runner.run">
        function <span class="apidocSignatureSpan">karma.runner.</span>run
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (config, done) {
  config = config || {}

  logger.setupFromConfig(config)

  done = helper.isFunction(done) ? done : process.exit
  config = cfg.parseConfig(config.configFile, config)

  var exitCode = 1
  var options = {
    hostname: config.hostname,
    path: config.urlRoot + &#x27;run&#x27;,
    port: config.port,
    method: &#x27;POST&#x27;,
    headers: {
      &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
    }
  }

  var request = http.request(options, function (response) {
    response.on(&#x27;data&#x27;, function (buffer) {
      var parsedResult = parseExitCode(buffer, exitCode, config.failOnEmptyTestSuite)
      exitCode = parsedResult.exitCode
      process.stdout.write(parsedResult.buffer)
    })

    response.on(&#x27;end&#x27;, function () {
      done(exitCode)
    })
  })

  request.on(&#x27;error&#x27;, function (e) {
    if (e.code === &#x27;ECONNREFUSED&#x27;) {
      log.error(&#x27;There is no server listening on port %d&#x27;, options.port)
      done(1, e.code)
    } else {
      throw e
    }
  })

  request.end(JSON.stringify({
    args: config.clientArgs,
    removedFiles: config.removedFiles,
    changedFiles: config.changedFiles,
    addedFiles: config.addedFiles,
    refresh: config.refresh,
    colors: config.colors
  }))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.server" id="apidoc.module.karma.server">module karma.server</a></h1>


    <h2>
        <a href="#apidoc.element.karma.server.start" id="apidoc.element.karma.server.start">
        function <span class="apidocSignatureSpan">karma.server.</span>start
        <span class="apidocSignatureSpan">(cliOptions, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (cliOptions, done) {
  console.error(&#x27;WARN `start` method is deprecated since 0.13. It will be removed in 0.14. Please use \n&#x27; +
    &#x27;  server = new Server(config, [done])\n&#x27; +
    &#x27;  server.start()\n&#x27; +
    &#x27;instead.&#x27;)
  var server = new Server(cliOptions, done)
  server.start()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.karma.stopper" id="apidoc.module.karma.stopper">module karma.stopper</a></h1>


    <h2>
        <a href="#apidoc.element.karma.stopper.stop" id="apidoc.element.karma.stopper.stop">
        function <span class="apidocSignatureSpan">karma.stopper.</span>stop
        <span class="apidocSignatureSpan">(config, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (config, done) {
  config = config || {}
  logger.setupFromConfig(config)
  done = helper.isFunction(done) ? done : process.exit
  var log = logger.create(&#x27;stopper&#x27;)
  config = cfg.parseConfig(config.configFile, config)

  var options = {
    hostname: config.hostname,
    path: config.urlRoot + &#x27;stop&#x27;,
    port: config.port,
    method: &#x27;GET&#x27;
  }

  var request = http.request(options)

  request.on(&#x27;response&#x27;, function (response) {
    if (response.statusCode !== 200) {
      log.error(&#x27;Server returned status code: &#x27; + response.statusCode)
      done(1)
      return
    }

    log.info(&#x27;Server stopped.&#x27;)
    done(0)
  })

  request.on(&#x27;error&#x27;, function (e) {
    if (e.code === &#x27;ECONNREFUSED&#x27;) {
      log.error(&#x27;There is no server listening on port %d&#x27;, options.port)
      done(1, e.code)
    } else {
      throw e
    }
  })
  request.end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
